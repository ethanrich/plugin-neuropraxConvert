<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Signal Processing (GNU Octave (version 7.2.0))</title>

<meta name="description" content="Signal Processing (GNU Octave (version 7.2.0))">
<meta name="keywords" content="Signal Processing (GNU Octave (version 7.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Image-Processing.html" rel="next" title="Image Processing">
<link href="Geometry.html" rel="prev" title="Geometry">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="chapter" id="Signal-Processing">
<div class="header">
<p>
Next: <a href="Image-Processing.html" accesskey="n" rel="next">Image Processing</a>, Previous: <a href="Geometry.html" accesskey="p" rel="prev">Geometry</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Signal-Processing-1"></span><h2 class="chapter">31 Signal Processing</h2>

<p>This chapter describes the signal processing and fast Fourier
transform functions available in Octave.  Fast Fourier transforms are
computed with the <small>FFTW</small> or <small>FFTPACK</small> libraries depending on how
Octave is built.
</p>
<span id="XREFfft"></span><dl class="def">
<dt id="index-fft"><span class="category">: </span><span><em></em> <strong>fft</strong> <em>(<var>x</var>)</em><a href='#index-fft' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fft-1"><span class="category">: </span><span><em></em> <strong>fft</strong> <em>(<var>x</var>, <var>n</var>)</em><a href='#index-fft-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fft-2"><span class="category">: </span><span><em></em> <strong>fft</strong> <em>(<var>x</var>, <var>n</var>, <var>dim</var>)</em><a href='#index-fft-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the discrete Fourier transform of <var>x</var> using
a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The FFT is calculated along the first non-singleton dimension of the
array.  Thus if <var>x</var> is a matrix, <code>fft (<var>x</var>)</code> computes the
FFT for each column of <var>x</var>.
</p>
<p>If called with two arguments, <var>n</var> is expected to be an integer
specifying the number of elements of <var>x</var> to use, or an empty
matrix to specify that its value should be ignored.  If <var>n</var> is
larger than the dimension along which the FFT is calculated, then
<var>x</var> is resized and padded with zeros.  Otherwise, if <var>n</var> is
smaller than the dimension along which the FFT is calculated, then
<var>x</var> is truncated.
</p>
<p>If called with three arguments, <var>dim</var> is an integer specifying the
dimension of the matrix along which the FFT is performed.
</p>
<p><strong>See also:</strong> <a href="#XREFifft">ifft</a>, <a href="#XREFfft2">fft2</a>, <a href="#XREFfftn">fftn</a>, <a href="#XREFfftw">fftw</a>.
</p></dd></dl>


<span id="XREFifft"></span><dl class="def">
<dt id="index-ifft"><span class="category">: </span><span><em></em> <strong>ifft</strong> <em>(<var>x</var>)</em><a href='#index-ifft' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ifft-1"><span class="category">: </span><span><em></em> <strong>ifft</strong> <em>(<var>x</var>, <var>n</var>)</em><a href='#index-ifft-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ifft-2"><span class="category">: </span><span><em></em> <strong>ifft</strong> <em>(<var>x</var>, <var>n</var>, <var>dim</var>)</em><a href='#index-ifft-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the inverse discrete Fourier transform of <var>x</var>
using a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The inverse FFT is calculated along the first non-singleton dimension
of the array.  Thus if <var>x</var> is a matrix, <code>fft (<var>x</var>)</code> computes
the inverse FFT for each column of <var>x</var>.
</p>
<p>If called with two arguments, <var>n</var> is expected to be an integer
specifying the number of elements of <var>x</var> to use, or an empty
matrix to specify that its value should be ignored.  If <var>n</var> is
larger than the dimension along which the inverse FFT is calculated, then
<var>x</var> is resized and padded with zeros.  Otherwise, if <var>n</var> is
smaller than the dimension along which the inverse FFT is calculated,
then <var>x</var> is truncated.
</p>
<p>If called with three arguments, <var>dim</var> is an integer specifying the
dimension of the matrix along which the inverse FFT is performed.
</p>
<p><strong>See also:</strong> <a href="#XREFfft">fft</a>, <a href="#XREFifft2">ifft2</a>, <a href="#XREFifftn">ifftn</a>, <a href="#XREFfftw">fftw</a>.
</p></dd></dl>


<span id="XREFfft2"></span><dl class="def">
<dt id="index-fft2"><span class="category">: </span><span><em></em> <strong>fft2</strong> <em>(<var>A</var>)</em><a href='#index-fft2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fft2-1"><span class="category">: </span><span><em></em> <strong>fft2</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>)</em><a href='#index-fft2-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the two-dimensional discrete Fourier transform of <var>A</var> using
a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional arguments <var>m</var> and <var>n</var> may be used specify the number of
rows and columns of <var>A</var> to use.  If either of these is larger than the
size of <var>A</var>, <var>A</var> is resized and padded with zeros.
</p>
<p>If <var>A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <var>A</var> is treated separately.
</p>
<p><strong>See also:</strong> <a href="#XREFifft2">ifft2</a>, <a href="#XREFfft">fft</a>, <a href="#XREFfftn">fftn</a>, <a href="#XREFfftw">fftw</a>.
</p></dd></dl>


<span id="XREFifft2"></span><dl class="def">
<dt id="index-ifft2"><span class="category">: </span><span><em></em> <strong>ifft2</strong> <em>(<var>A</var>)</em><a href='#index-ifft2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ifft2-1"><span class="category">: </span><span><em></em> <strong>ifft2</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>)</em><a href='#index-ifft2-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the inverse two-dimensional discrete Fourier transform of <var>A</var>
using a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional arguments <var>m</var> and <var>n</var> may be used specify the number of
rows and columns of <var>A</var> to use.  If either of these is larger than the
size of <var>A</var>, <var>A</var> is resized and padded with zeros.
</p>
<p>If <var>A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <var>A</var> is treated separately.
</p>
<p><strong>See also:</strong> <a href="#XREFfft2">fft2</a>, <a href="#XREFifft">ifft</a>, <a href="#XREFifftn">ifftn</a>, <a href="#XREFfftw">fftw</a>.
</p></dd></dl>


<span id="XREFfftn"></span><dl class="def">
<dt id="index-fftn"><span class="category">: </span><span><em></em> <strong>fftn</strong> <em>(<var>A</var>)</em><a href='#index-fftn' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftn-1"><span class="category">: </span><span><em></em> <strong>fftn</strong> <em>(<var>A</var>, <var>size</var>)</em><a href='#index-fftn-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the N-dimensional discrete Fourier transform of <var>A</var> using
a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional vector argument <var>size</var> may be used specify the dimensions
of the array to be used.  If an element of <var>size</var> is smaller than the
corresponding dimension of <var>A</var>, then the dimension of <var>A</var> is
truncated prior to performing the FFT.  Otherwise, if an element of
<var>size</var> is larger than the corresponding dimension then <var>A</var> is
resized and padded with zeros.
</p>
<p><strong>See also:</strong> <a href="#XREFifftn">ifftn</a>, <a href="#XREFfft">fft</a>, <a href="#XREFfft2">fft2</a>, <a href="#XREFfftw">fftw</a>.
</p></dd></dl>


<span id="XREFifftn"></span><dl class="def">
<dt id="index-ifftn"><span class="category">: </span><span><em></em> <strong>ifftn</strong> <em>(<var>A</var>)</em><a href='#index-ifftn' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ifftn-1"><span class="category">: </span><span><em></em> <strong>ifftn</strong> <em>(<var>A</var>, <var>size</var>)</em><a href='#index-ifftn-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the inverse N-dimensional discrete Fourier transform of <var>A</var>
using a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional vector argument <var>size</var> may be used specify the dimensions
of the array to be used.  If an element of <var>size</var> is smaller than the
corresponding dimension of <var>A</var>, then the dimension of <var>A</var> is
truncated prior to performing the inverse FFT.  Otherwise, if an element of
<var>size</var> is larger than the corresponding dimension then <var>A</var> is
resized and padded with zeros.
</p>
<p><strong>See also:</strong> <a href="#XREFfftn">fftn</a>, <a href="#XREFifft">ifft</a>, <a href="#XREFifft2">ifft2</a>, <a href="#XREFfftw">fftw</a>.
</p></dd></dl>


<p>Octave uses the <small>FFTW</small> libraries to perform FFT computations.  When Octave
starts up and initializes the <small>FFTW</small> libraries, they read a system wide
file (on a Unix system, it is typically <samp>/etc/fftw/wisdom</samp>) that
contains information useful to speed up FFT computations.  This
information is called the <em>wisdom</em>.  The system-wide file allows
wisdom to be shared between all applications using the <small>FFTW</small> libraries.
</p>
<p>Use the <code>fftw</code> function to generate and save wisdom.  Using the
utilities provided together with the <small>FFTW</small> libraries
(<code>fftw-wisdom</code> on Unix systems), you can even add wisdom
generated by Octave to the system-wide wisdom file.
</p>
<span id="XREFfftw"></span><dl class="def">
<dt id="index-fftw"><span class="category">: </span><span><em><var>method</var> =</em> <strong>fftw</strong> <em>(&quot;planner&quot;)</em><a href='#index-fftw' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftw-1"><span class="category">: </span><span><em></em> <strong>fftw</strong> <em>(&quot;planner&quot;, <var>method</var>)</em><a href='#index-fftw-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftw-2"><span class="category">: </span><span><em><var>wisdom</var> =</em> <strong>fftw</strong> <em>(&quot;dwisdom&quot;)</em><a href='#index-fftw-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftw-3"><span class="category">: </span><span><em></em> <strong>fftw</strong> <em>(&quot;dwisdom&quot;, <var>wisdom</var>)</em><a href='#index-fftw-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftw-4"><span class="category">: </span><span><em></em> <strong>fftw</strong> <em>(&quot;threads&quot;, <var>nthreads</var>)</em><a href='#index-fftw-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftw-5"><span class="category">: </span><span><em><var>nthreads</var> =</em> <strong>fftw</strong> <em>(&quot;threads&quot;)</em><a href='#index-fftw-5' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Manage <small>FFTW</small> wisdom data.
</p>
<p>Wisdom data can be used to significantly accelerate the calculation of the
FFTs, but implies an initial cost in its calculation.  When the <small>FFTW</small>
libraries are initialized, they read a system wide wisdom file (typically in
<samp>/etc/fftw/wisdom</samp>), allowing wisdom to be shared between applications
other than Octave.  Alternatively, the <code>fftw</code> function can be used to
import wisdom.  For example,
</p>
<div class="example">
<pre class="example"><var>wisdom</var> = fftw (&quot;dwisdom&quot;)
</pre></div>

<p>will save the existing wisdom used by Octave to the string <var>wisdom</var>.
This string can then be saved to a file and restored using the <code>save</code>
and <code>load</code> commands respectively.  This existing wisdom can be
re-imported as follows
</p>
<div class="example">
<pre class="example">fftw (&quot;dwisdom&quot;, <var>wisdom</var>)
</pre></div>

<p>If <var>wisdom</var> is an empty string, then the wisdom used is cleared.
</p>
<p>During the calculation of Fourier transforms further wisdom is generated.
The fashion in which this wisdom is generated is also controlled by
the <code>fftw</code> function.  There are five different manners in which the
wisdom can be treated:
</p>
<dl compact="compact">
<dt><span><code>&quot;estimate&quot;</code></span></dt>
<dd><p>Specifies that no run-time measurement of the optimal means of
calculating a particular is performed, and a simple heuristic is used
to pick a (probably sub-optimal) plan.  The advantage of this method is
that there is little or no overhead in the generation of the plan, which
is appropriate for a Fourier transform that will be calculated once.
</p>
</dd>
<dt><span><code>&quot;measure&quot;</code></span></dt>
<dd><p>In this case a range of algorithms to perform the transform is considered
and the best is selected based on their execution time.
</p>
</dd>
<dt><span><code>&quot;patient&quot;</code></span></dt>
<dd><p>Similar to <code>&quot;measure&quot;</code>, but a wider range of algorithms is
considered.
</p>
</dd>
<dt><span><code>&quot;exhaustive&quot;</code></span></dt>
<dd><p>Like <code>&quot;measure&quot;</code>, but all possible algorithms that may be used to
treat the transform are considered.
</p>
</dd>
<dt><span><code>&quot;hybrid&quot;</code></span></dt>
<dd><p>As run-time measurement of the algorithm can be expensive, this is a
compromise where <code>&quot;measure&quot;</code> is used for transforms up to the size
of 8192 and beyond that the <code>&quot;estimate&quot;</code> method is used.
</p></dd>
</dl>

<p>The default method is <code>&quot;estimate&quot;</code>.  The current method can
be queried with
</p>
<div class="example">
<pre class="example"><var>method</var> = fftw (&quot;planner&quot;)
</pre></div>

<p>or set by using
</p>
<div class="example">
<pre class="example">fftw (&quot;planner&quot;, <var>method</var>)
</pre></div>

<p>Note that calculated wisdom will be lost when restarting Octave.  However,
the wisdom data can be reloaded if it is saved to a file as described
above.  Saved wisdom files should not be used on different platforms since
they will not be efficient and the point of calculating the wisdom is lost.
</p>
<p>The number of threads used for computing the plans and executing the
transforms can be set with
</p>
<div class="example">
<pre class="example">fftw (&quot;threads&quot;, <var>NTHREADS</var>)
</pre></div>

<p>Note that octave must be compiled with multi-threaded <small>FFTW</small> support for
this feature.  The number of processors available to the current process is
used per default.
</p>

<p><strong>See also:</strong> <a href="#XREFfft">fft</a>, <a href="#XREFifft">ifft</a>, <a href="#XREFfft2">fft2</a>, <a href="#XREFifft2">ifft2</a>, <a href="#XREFfftn">fftn</a>, <a href="#XREFifftn">ifftn</a>.
</p></dd></dl>


<span id="XREFfftconv"></span><dl class="def">
<dt id="index-fftconv"><span class="category">: </span><span><em></em> <strong>fftconv</strong> <em>(<var>x</var>, <var>y</var>)</em><a href='#index-fftconv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftconv-1"><span class="category">: </span><span><em></em> <strong>fftconv</strong> <em>(<var>x</var>, <var>y</var>, <var>n</var>)</em><a href='#index-fftconv-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convolve two vectors using the FFT for computation.
</p>
<p><code>c = fftconv (<var>x</var>, <var>y</var>)</code> returns a vector of length equal to
<code>length (<var>x</var>) + length (<var>y</var>) - 1</code>.  If <var>x</var> and <var>y</var>
are the coefficient vectors of two polynomials, the returned value is the
coefficient vector of the product polynomial.
</p>
<p>The computation uses the FFT by calling the function <code>fftfilt</code>.  If
the optional argument <var>n</var> is specified, an N-point FFT is used.
</p>
<p><strong>See also:</strong> <a href="Products-of-Polynomials.html#XREFdeconv">deconv</a>, <a href="Products-of-Polynomials.html#XREFconv">conv</a>, <a href="Products-of-Polynomials.html#XREFconv2">conv2</a>.
</p></dd></dl>


<span id="XREFfftfilt"></span><dl class="def">
<dt id="index-fftfilt"><span class="category">: </span><span><em></em> <strong>fftfilt</strong> <em>(<var>b</var>, <var>x</var>)</em><a href='#index-fftfilt' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftfilt-1"><span class="category">: </span><span><em></em> <strong>fftfilt</strong> <em>(<var>b</var>, <var>x</var>, <var>n</var>)</em><a href='#index-fftfilt-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Filter <var>x</var> with the FIR filter <var>b</var> using the FFT.
</p>
<p>If <var>x</var> is a matrix, filter each column of the matrix.
</p>
<p>Given the optional third argument, <var>n</var>, <code>fftfilt</code> uses the
overlap-add method to filter <var>x</var> with <var>b</var> using an N-point FFT.
The FFT size must be an even power of 2 and must be greater than or equal to
the length of <var>b</var>.  If the specified <var>n</var> does not meet these
criteria, it is automatically adjusted to the nearest value that does.
</p>

<p><strong>See also:</strong> <a href="#XREFfilter">filter</a>, <a href="#XREFfilter2">filter2</a>.
</p></dd></dl>


<span id="XREFfilter"></span><dl class="def">
<dt id="index-filter"><span class="category">: </span><span><em><var>y</var> =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>)</em><a href='#index-filter' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-filter-1"><span class="category">: </span><span><em>[<var>y</var>, <var>sf</var>] =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>, <var>si</var>)</em><a href='#index-filter-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-filter-2"><span class="category">: </span><span><em>[<var>y</var>, <var>sf</var>] =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>, [], <var>dim</var>)</em><a href='#index-filter-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-filter-3"><span class="category">: </span><span><em>[<var>y</var>, <var>sf</var>] =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>, <var>si</var>, <var>dim</var>)</em><a href='#index-filter-3' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Apply a 1-D digital filter to the data <var>x</var>.
</p>
<p><code>filter</code> returns the solution to the following linear, time-invariant
difference equation:
</p>
<div class="example">
<pre class="example"> N                   M
SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1&lt;=n&lt;=length(x)
k=0                 k=0
</pre></div>


<p>where
N=length(a)-1 and M=length(b)-1.
The result is calculated over the first non-singleton dimension of <var>x</var>
or over <var>dim</var> if supplied.
</p>
<p>An equivalent form of the equation is:
</p>
<div class="example">
<pre class="example">          N                   M
y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&lt;=n&lt;=length(x)
         k=1                 k=0
</pre></div>


<p>where
 c = a/a(1) and d = b/a(1).
</p>
<p>If the fourth argument <var>si</var> is provided, it is taken as the
initial state of the system and the final state is returned as
<var>sf</var>.  The state vector is a column vector whose length is
equal to the length of the longest coefficient vector minus one.
If <var>si</var> is not supplied, the initial state vector is set to all
zeros.
</p>
<p>In terms of the Z Transform, <var>y</var> is the result of passing the
discrete-time signal <var>x</var> through a system characterized by the following
rational system function:
</p>
<div class="example">
<pre class="example">          M
         SUM d(k+1) z^(-k)
         k=0
H(z) = ---------------------
            N
       1 + SUM c(k+1) z^(-k)
           k=1
</pre></div>


<p><strong>See also:</strong> <a href="#XREFfilter2">filter2</a>, <a href="#XREFfftfilt">fftfilt</a>, <a href="#XREFfreqz">freqz</a>.
</p></dd></dl>


<span id="XREFfilter2"></span><dl class="def">
<dt id="index-filter2"><span class="category">: </span><span><em><var>y</var> =</em> <strong>filter2</strong> <em>(<var>b</var>, <var>x</var>)</em><a href='#index-filter2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-filter2-1"><span class="category">: </span><span><em><var>y</var> =</em> <strong>filter2</strong> <em>(<var>b</var>, <var>x</var>, <var>shape</var>)</em><a href='#index-filter2-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Apply the 2-D FIR filter <var>b</var> to <var>x</var>.
</p>
<p>If the argument <var>shape</var> is specified, return an array of the desired
shape.  Possible values are:
</p>
<dl compact="compact">
<dt><span><code>&quot;full&quot;</code></span></dt>
<dd><p>pad <var>x</var> with zeros on all sides before filtering.
</p>
</dd>
<dt><span><code>&quot;same&quot;</code></span></dt>
<dd><p>unpadded <var>x</var> (default)
</p>
</dd>
<dt><span><code>&quot;valid&quot;</code></span></dt>
<dd><p>trim <var>x</var> after filtering so edge effects are no included.
</p></dd>
</dl>

<p>Note this is just a variation on convolution, with the parameters reversed
and <var>b</var> rotated 180 degrees.
</p>
<p><strong>See also:</strong> <a href="Products-of-Polynomials.html#XREFconv2">conv2</a>.
</p></dd></dl>


<span id="XREFfreqz"></span><dl class="def">
<dt id="index-freqz"><span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>, <var>n</var>, &quot;whole&quot;)</em><a href='#index-freqz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz-1"><span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>)</em><a href='#index-freqz-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz-2"><span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>)</em><a href='#index-freqz-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz-3"><span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>, <var>n</var>)</em><a href='#index-freqz-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz-4"><span class="category">: </span><span><em><var>h</var> =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>, <var>w</var>)</em><a href='#index-freqz-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz-5"><span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(&hellip;, <var>Fs</var>)</em><a href='#index-freqz-5' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz-6"><span class="category">: </span><span><em></em> <strong>freqz</strong> <em>(&hellip;)</em><a href='#index-freqz-6' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Return the complex frequency response <var>h</var> of the rational IIR filter
whose numerator and denominator coefficients are <var>b</var> and <var>a</var>,
respectively.
</p>
<p>The response is evaluated at <var>n</var> angular frequencies between 0 and
2*pi.
</p>
<p>The output value <var>w</var> is a vector of the frequencies.
</p>
<p>If <var>a</var> is omitted, the denominator is assumed to be 1 (this
corresponds to a simple FIR filter).
</p>
<p>If <var>n</var> is omitted, a value of 512 is assumed.  For fastest computation,
<var>n</var> should factor into a small number of small primes.
</p>
<p>If the fourth argument, <code>&quot;whole&quot;</code>, is omitted the response is
evaluated at frequencies between 0 and
pi.
</p>
<p><code>freqz (<var>b</var>, <var>a</var>, <var>w</var>)</code>
</p>
<p>Evaluate the response at the specific frequencies in the vector <var>w</var>.
The values for <var>w</var> are measured in radians.
</p>
<p><code>[&hellip;] = freqz (&hellip;, <var>Fs</var>)</code>
</p>
<p>Return frequencies in Hz instead of radians assuming a sampling rate
<var>Fs</var>.  If you are evaluating the response at specific frequencies
<var>w</var>, those frequencies should be requested in Hz rather than radians.
</p>
<p><code>freqz (&hellip;)</code>
</p>
<p>Plot the magnitude and phase response of <var>h</var> rather than returning them.
</p>

<p><strong>See also:</strong> <a href="#XREFfreqz_005fplot">freqz_plot</a>.
</p></dd></dl>


<span id="XREFfreqz_005fplot"></span><dl class="def">
<dt id="index-freqz_005fplot"><span class="category">: </span><span><em></em> <strong>freqz_plot</strong> <em>(<var>w</var>, <var>h</var>)</em><a href='#index-freqz_005fplot' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-freqz_005fplot-1"><span class="category">: </span><span><em></em> <strong>freqz_plot</strong> <em>(<var>w</var>, <var>h</var>, <var>freq_norm</var>)</em><a href='#index-freqz_005fplot-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Plot the magnitude and phase response of <var>h</var>.
</p>
<p>If the optional <var>freq_norm</var> argument is true, the frequency vector
<var>w</var> is in units of normalized radians.  If <var>freq_norm</var> is false, or
not given, then <var>w</var> is measured in Hertz.
</p>
<p><strong>See also:</strong> <a href="#XREFfreqz">freqz</a>.
</p></dd></dl>


<span id="XREFsinc"></span><dl class="def">
<dt id="index-sinc"><span class="category">: </span><span><em></em> <strong>sinc</strong> <em>(<var>x</var>)</em><a href='#index-sinc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the sinc function.
</p>
<p>Return
sin (pi*x) / (pi*x).
</p></dd></dl>


<span id="XREFunwrap"></span><dl class="def">
<dt id="index-unwrap"><span class="category">: </span><span><em><var>b</var> =</em> <strong>unwrap</strong> <em>(<var>x</var>)</em><a href='#index-unwrap' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-unwrap-1"><span class="category">: </span><span><em><var>b</var> =</em> <strong>unwrap</strong> <em>(<var>x</var>, <var>tol</var>)</em><a href='#index-unwrap-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-unwrap-2"><span class="category">: </span><span><em><var>b</var> =</em> <strong>unwrap</strong> <em>(<var>x</var>, <var>tol</var>, <var>dim</var>)</em><a href='#index-unwrap-2' class='copiable-anchor'> &para;</a></span></dt>
<dd>
<p>Unwrap radian phases by adding or subtracting multiples of 2*pi as
appropriate to remove jumps greater than <var>tol</var>.
</p>
<p><var>tol</var> defaults to pi.
</p>
<p>Unwrap will work along the dimension <var>dim</var>.  If <var>dim</var>
is unspecified it defaults to the first non-singleton dimension.
</p></dd></dl>



<span id="XREFarch_005ffit"></span><dl class="def">
<dt id="index-arch_005ffit"><span class="category">: </span><span><em>[<var>a</var>, <var>b</var>] =</em> <strong>arch_fit</strong> <em>(<var>y</var>, <var>x</var>, <var>p</var>, <var>iter</var>, <var>gamma</var>, <var>a0</var>, <var>b0</var>)</em><a href='#index-arch_005ffit' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Fit an ARCH regression model to the time series <var>y</var> using the scoring
algorithm in Engle&rsquo;s original ARCH paper.
</p>
<p>The model is
</p>
<div class="example">
<pre class="example">y(t) = b(1) * x(t,1) + &hellip; + b(k) * x(t,k) + e(t),
h(t) = a(1) + a(2) * e(t-1)^2 + &hellip; + a(p+1) * e(t-p)^2
</pre></div>

<p>in which <em class='math'>e(t)</em> is <em class='math'>N(0, h(t))</em>, given a time-series vector
<var>y</var> up to time <em class='math'>t-1</em> and a matrix of (ordinary) regressors <var>x</var>
up to <em class='math'>t</em>.  The order of the regression of the residual variance is
specified by <var>p</var>.
</p>
<p>If invoked as <code>arch_fit (<var>y</var>, <var>k</var>, <var>p</var>)</code> with a positive
integer <var>k</var>, fit an ARCH(<var>k</var>, <var>p</var>) process, i.e., do the above
with the <em class='math'>t</em>-th row of <var>x</var> given by
</p>
<div class="example">
<pre class="example">[1, y(t-1), &hellip;, y(t-k)]
</pre></div>

<p>Optionally, one can specify the number of iterations <var>iter</var>, the
updating factor <var>gamma</var>, and initial values <em class='math'>a0</em> and <em class='math'>b0</em>
for the scoring algorithm.
</p></dd></dl>


<span id="XREFarch_005frnd"></span><dl class="def">
<dt id="index-arch_005frnd"><span class="category">: </span><span><em></em> <strong>arch_rnd</strong> <em>(<var>a</var>, <var>b</var>, <var>t</var>)</em><a href='#index-arch_005frnd' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Simulate an ARCH sequence of length <var>t</var> with AR coefficients <var>b</var> and
CH coefficients <var>a</var>.
</p>
<p>The result <em class='math'>y(t)</em> follows the model
</p>
<div class="example">
<pre class="example">y(t) = b(1) + b(2) * y(t-1) + &hellip; + b(lb) * y(t-lb+1) + e(t),
</pre></div>

<p>where <em class='math'>e(t)</em>, given <var>y</var> up to time <em class='math'>t-1</em>, is
<em class='math'>N(0, h(t))</em>, with
</p>
<div class="example">
<pre class="example">h(t) = a(1) + a(2) * e(t-1)^2 + &hellip; + a(la) * e(t-la+1)^2
</pre></div>
</dd></dl>


<span id="XREFarch_005ftest"></span><dl class="def">
<dt id="index-arch_005ftest"><span class="category">: </span><span><em>[<var>pval</var>, <var>lm</var>] =</em> <strong>arch_test</strong> <em>(<var>y</var>, <var>x</var>, <var>p</var>)</em><a href='#index-arch_005ftest' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>For a linear regression model
</p>
<div class="example">
<pre class="example">y = x * b + e
</pre></div>

<p>perform a Lagrange Multiplier (LM) test of the null hypothesis of no
conditional heteroscedascity against the alternative of CH(<var>p</var>).
</p>
<p>I.e., the model is
</p>
<div class="example">
<pre class="example">y(t) = b(1) * x(t,1) + &hellip; + b(k) * x(t,k) + e(t),
</pre></div>

<p>given <var>y</var> up to <em class='math'>t-1</em> and <var>x</var> up to <em class='math'>t</em>,
<em class='math'>e</em>(t) is <em class='math'>N(0, h(t))</em> with
</p>
<div class="example">
<pre class="example">h(t) = v + a(1) * e(t-1)^2 + &hellip; + a(p) * e(t-p)^2,
</pre></div>

<p>and the null is <em class='math'>a(1)</em> == &hellip; == <em class='math'>a(p)</em> == 0.
</p>
<p>If the second argument is a scalar integer, <em class='math'>k</em>, perform the same
test in a linear autoregression model of order <em class='math'>k</em>, i.e., with
</p>
<div class="example">
<pre class="example">[1, y(t-1), &hellip;, y(t-<var>k</var>)]
</pre></div>

<p>as the <em class='math'>t</em>-th row of <var>x</var>.
</p>
<p>Under the null, LM approximately has a chisquare distribution with
<var>p</var> degrees of freedom and <var>pval</var> is the <em class='math'>p</em>-value (1
minus the CDF of this distribution at LM) of the test.
</p>
<p>If no output argument is given, the <em class='math'>p</em>-value is displayed.
</p></dd></dl>


<span id="XREFarma_005frnd"></span><dl class="def">
<dt id="index-arma_005frnd"><span class="category">: </span><span><em></em> <strong>arma_rnd</strong> <em>(<var>a</var>, <var>b</var>, <var>v</var>, <var>t</var>, <var>n</var>)</em><a href='#index-arma_005frnd' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return a simulation of the ARMA model.
</p>
<p>The ARMA model is defined by
</p>
<div class="example">
<pre class="example">x(n) = a(1) * x(n-1) + &hellip; + a(k) * x(n-k)
     + e(n) + b(1) * e(n-1) + &hellip; + b(l) * e(n-l)
</pre></div>

<p>in which <var>k</var> is the length of vector <var>a</var>, <var>l</var> is the length of
vector <var>b</var> and <var>e</var> is Gaussian white noise with variance <var>v</var>.
The function returns a vector of length <var>t</var>.
</p>
<p>The optional parameter <var>n</var> gives the number of dummy <var>x</var>(<var>i</var>)
used for initialization, i.e., a sequence of length <var>t</var>+<var>n</var> is
generated and <var>x</var>(<var>n</var>+1:<var>t</var>+<var>n</var>) is returned.  If <var>n</var>
is omitted, <var>n</var> = 100 is used.
</p></dd></dl>


<span id="XREFautoreg_005fmatrix"></span><dl class="def">
<dt id="index-autoreg_005fmatrix"><span class="category">: </span><span><em></em> <strong>autoreg_matrix</strong> <em>(<var>y</var>, <var>k</var>)</em><a href='#index-autoreg_005fmatrix' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Given a time series (vector) <var>y</var>, return a matrix with ones in the first
column and the first <var>k</var> lagged values of <var>y</var> in the other columns.
</p>
<p>In other words, for <var>t</var> &gt; <var>k</var>,
<code>[1, <var>y</var>(<var>t</var>-1), &hellip;, <var>y</var>(<var>t</var>-<var>k</var>)]</code> is the
t-th row of the result.
</p>
<p>The resulting matrix may be used as a regressor matrix in autoregressions.
</p></dd></dl>


<span id="XREFbartlett"></span><dl class="def">
<dt id="index-bartlett"><span class="category">: </span><span><em></em> <strong>bartlett</strong> <em>(<var>m</var>)</em><a href='#index-bartlett' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Bartlett (triangular) window of length
<var>m</var>.
</p>
<p>For a definition of the Bartlett window see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite>Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<span id="XREFblackman"></span><dl class="def">
<dt id="index-blackman"><span class="category">: </span><span><em></em> <strong>blackman</strong> <em>(<var>m</var>)</em><a href='#index-blackman' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-blackman-1"><span class="category">: </span><span><em></em> <strong>blackman</strong> <em>(<var>m</var>, &quot;periodic&quot;)</em><a href='#index-blackman-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-blackman-2"><span class="category">: </span><span><em></em> <strong>blackman</strong> <em>(<var>m</var>, &quot;symmetric&quot;)</em><a href='#index-blackman-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Blackman window of length
<var>m</var>.
</p>
<p>If the optional argument <code>&quot;periodic&quot;</code> is given, the periodic form
of the window is returned.  This is equivalent to the window of length
<var>m</var>+1 with the last coefficient removed.  The optional argument
<code>&quot;symmetric&quot;</code> is equivalent to not specifying a second argument.
</p>
<p>For a definition of the Blackman window, see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite>Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<span id="XREFdetrend"></span><dl class="def">
<dt id="index-detrend"><span class="category">: </span><span><em></em> <strong>detrend</strong> <em>(<var>x</var>, <var>p</var>)</em><a href='#index-detrend' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>If <var>x</var> is a vector, <code>detrend (<var>x</var>, <var>p</var>)</code> removes the
best fit of a polynomial of order <var>p</var> from the data <var>x</var>.
</p>
<p>If <var>x</var> is a matrix, <code>detrend (<var>x</var>, <var>p</var>)</code> does the same
for each column in <var>x</var>.
</p>
<p>The second argument <var>p</var> is optional.  If it is not specified, a value of
1 is assumed.  This corresponds to removing a linear trend.
</p>
<p>The order of the polynomial can also be given as a string, in which case
<var>p</var> must be either <code>&quot;constant&quot;</code> (corresponds to <code><var>p</var>=0</code>)
or <code>&quot;linear&quot;</code> (corresponds to <code><var>p</var>=1</code>).
</p>
<p><strong>See also:</strong> <a href="Polynomial-Interpolation.html#XREFpolyfit">polyfit</a>.
</p></dd></dl>


<span id="XREFdiffpara"></span><dl class="def">
<dt id="index-diffpara"><span class="category">: </span><span><em>[<var>d</var>, <var>dd</var>] =</em> <strong>diffpara</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>)</em><a href='#index-diffpara' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the estimator <var>d</var> for the differencing parameter of an
integrated time series.
</p>
<p>The frequencies from <em class='math'>[2*pi*a/t, 2*pi*b/T]</em> are used for the
estimation.  If <var>b</var> is omitted, the interval
<em class='math'>[2*pi/T, 2*pi*a/T]</em> is used.  If both <var>b</var> and <var>a</var> are omitted
then <em class='math'>a = 0.5 * sqrt (T)</em> and <em class='math'>b = 1.5 * sqrt (T)</em> is used, where
<em class='math'>T</em> is the sample size.  If <var>x</var> is a matrix, the differencing
parameter of each column is estimated.
</p>
<p>The estimators for all frequencies in the intervals described above is
returned in <var>dd</var>.
</p>
<p>The value of <var>d</var> is simply the mean of <var>dd</var>.
</p>
<p>Reference: P.J. Brockwell &amp; R.A. Davis. <cite>Time Series:
Theory and Methods</cite>. Springer 1987.
</p></dd></dl>


<span id="XREFdurbinlevinson"></span><dl class="def">
<dt id="index-durbinlevinson"><span class="category">: </span><span><em></em> <strong>durbinlevinson</strong> <em>(<var>c</var>, <var>oldphi</var>, <var>oldv</var>)</em><a href='#index-durbinlevinson' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Perform one step of the Durbin-Levinson algorithm.
</p>
<p>The vector <var>c</var> specifies the autocovariances
<code>[gamma_0, &hellip;, gamma_t]</code> from lag 0 to <var>t</var>, <var>oldphi</var>
specifies the coefficients based on <var>c</var>(<var>t</var>-1) and <var>oldv</var>
specifies the corresponding error.
</p>
<p>If <var>oldphi</var> and <var>oldv</var> are omitted, all steps from 1 to <var>t</var> of
the algorithm are performed.
</p></dd></dl>


<span id="XREFfftshift"></span><dl class="def">
<dt id="index-fftshift"><span class="category">: </span><span><em></em> <strong>fftshift</strong> <em>(<var>x</var>)</em><a href='#index-fftshift' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-fftshift-1"><span class="category">: </span><span><em></em> <strong>fftshift</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href='#index-fftshift-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Perform a shift of the vector <var>x</var>, for use with the <code>fft</code> and
<code>ifft</code> functions, in order to move the frequency 0 to the center of
the vector or matrix.
</p>
<p>If <var>x</var> is a vector of <em class='math'>N</em> elements corresponding to <em class='math'>N</em> time
samples spaced by <em class='math'>dt</em>, then
<code>fftshift (fft (<var>x</var>))</code> corresponds to frequencies
</p>
<div class="example">
<pre class="example">f = [ -(ceil((N-1)/2):-1:1), 0, (1:floor((N-1)/2)) ] * df
</pre></div>

<p>where <em class='math'>df = 1 / (N * dt)</em>.
</p>
<p>If <var>x</var> is a matrix, the same holds for rows and columns.  If <var>x</var>
is an array, then the same holds along each dimension.
</p>
<p>The optional <var>dim</var> argument can be used to limit the dimension along
which the permutation occurs.
</p>
<p><strong>See also:</strong> <a href="#XREFifftshift">ifftshift</a>.
</p></dd></dl>


<span id="XREFifftshift"></span><dl class="def">
<dt id="index-ifftshift"><span class="category">: </span><span><em></em> <strong>ifftshift</strong> <em>(<var>x</var>)</em><a href='#index-ifftshift' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ifftshift-1"><span class="category">: </span><span><em></em> <strong>ifftshift</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href='#index-ifftshift-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Undo the action of the <code>fftshift</code> function.
</p>
<p>For even length <var>x</var>, <code>fftshift</code> is its own inverse, but odd lengths
differ slightly.
</p>
<p><strong>See also:</strong> <a href="#XREFfftshift">fftshift</a>.
</p></dd></dl>


<span id="XREFfractdiff"></span><dl class="def">
<dt id="index-fractdiff"><span class="category">: </span><span><em></em> <strong>fractdiff</strong> <em>(<var>x</var>, <var>d</var>)</em><a href='#index-fractdiff' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the fractional differences <em class='math'>(1-L)^d x</em> where <em class='math'>L</em>
denotes the lag-operator and <em class='math'>d</em> is greater than -1.
</p></dd></dl>


<span id="XREFhamming"></span><dl class="def">
<dt id="index-hamming"><span class="category">: </span><span><em></em> <strong>hamming</strong> <em>(<var>m</var>)</em><a href='#index-hamming' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-hamming-1"><span class="category">: </span><span><em></em> <strong>hamming</strong> <em>(<var>m</var>, &quot;periodic&quot;)</em><a href='#index-hamming-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-hamming-2"><span class="category">: </span><span><em></em> <strong>hamming</strong> <em>(<var>m</var>, &quot;symmetric&quot;)</em><a href='#index-hamming-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Hamming window of length <var>m</var>.
</p>
<p>If the optional argument <code>&quot;periodic&quot;</code> is given, the periodic form
of the window is returned.  This is equivalent to the window of length
<var>m</var>+1 with the last coefficient removed.  The optional argument
<code>&quot;symmetric&quot;</code> is equivalent to not specifying a second argument.
</p>
<p>For a definition of the Hamming window see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite>Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<span id="XREFhanning"></span><dl class="def">
<dt id="index-hanning"><span class="category">: </span><span><em></em> <strong>hanning</strong> <em>(<var>m</var>)</em><a href='#index-hanning' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-hanning-1"><span class="category">: </span><span><em></em> <strong>hanning</strong> <em>(<var>m</var>, &quot;periodic&quot;)</em><a href='#index-hanning-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-hanning-2"><span class="category">: </span><span><em></em> <strong>hanning</strong> <em>(<var>m</var>, &quot;symmetric&quot;)</em><a href='#index-hanning-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Hanning window of length <var>m</var>.
</p>
<p>If the optional argument <code>&quot;periodic&quot;</code> is given, the periodic form
of the window is returned.  This is equivalent to the window of length
<var>m</var>+1 with the last coefficient removed.  The optional argument
<code>&quot;symmetric&quot;</code> is equivalent to not specifying a second argument.
</p>
<p>For a definition of the Hanning window see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite>Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<span id="XREFhurst"></span><dl class="def">
<dt id="index-hurst"><span class="category">: </span><span><em></em> <strong>hurst</strong> <em>(<var>x</var>)</em><a href='#index-hurst' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Estimate the Hurst parameter of sample <var>x</var> via the rescaled range
statistic.
</p>
<p>If <var>x</var> is a matrix, the parameter is estimated for every column.
</p></dd></dl>


<span id="XREFpchip"></span><dl class="def">
<dt id="index-pchip"><span class="category">: </span><span><em><var>pp</var> =</em> <strong>pchip</strong> <em>(<var>x</var>, <var>y</var>)</em><a href='#index-pchip' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-pchip-1"><span class="category">: </span><span><em><var>yi</var> =</em> <strong>pchip</strong> <em>(<var>x</var>, <var>y</var>, <var>xi</var>)</em><a href='#index-pchip-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
points <var>x</var> and <var>y</var>.
</p>
<p>If called with two arguments, return the piecewise polynomial <var>pp</var>
that may be used with <code>ppval</code> to evaluate the polynomial at specific
points.
</p>
<p>When called with a third input argument, <code>pchip</code> evaluates the pchip
polynomial at the points <var>xi</var>.  The third calling form is equivalent to
<code>ppval (pchip (<var>x</var>, <var>y</var>), <var>xi</var>)</code>.
</p>
<p>The variable <var>x</var> must be a strictly monotonic vector (either increasing
or decreasing) of length <var>n</var>.
</p>
<p><var>y</var> can be either a vector or array.  If <var>y</var> is a vector then it
must be the same length <var>n</var> as <var>x</var>.  If <var>y</var> is an array then
the size of <var>y</var> must have the form
<code>[<var>s1</var>, <var>s2</var>, &hellip;, <var>sk</var>, <var>n</var>]</code>
The array is reshaped internally to a matrix where the leading dimension is
given by
<code><var>s1</var> * <var>s2</var> * &hellip; * <var>sk</var></code>
and each row of this matrix is then treated separately.  Note that this is
exactly opposite to <code>interp1</code> but is done for <small>MATLAB</small>
compatibility.
</p>

<p><strong>See also:</strong> <a href="One_002ddimensional-Interpolation.html#XREFspline">spline</a>, <a href="Polynomial-Interpolation.html#XREFppval">ppval</a>, <a href="Polynomial-Interpolation.html#XREFmkpp">mkpp</a>, <a href="Polynomial-Interpolation.html#XREFunmkpp">unmkpp</a>.
</p></dd></dl>


<span id="XREFperiodogram"></span><dl class="def">
<dt id="index-periodogram"><span class="category">: </span><span><em>[<var>Pxx</var>, <var>w</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>)</em><a href='#index-periodogram' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-periodogram-1"><span class="category">: </span><span><em>[<var>Pxx</var>, <var>w</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>, <var>win</var>)</em><a href='#index-periodogram-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-periodogram-2"><span class="category">: </span><span><em>[<var>Pxx</var>, <var>w</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>, <var>win</var>, <var>nfft</var>)</em><a href='#index-periodogram-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-periodogram-3"><span class="category">: </span><span><em>[<var>Pxx</var>, <var>f</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>, <var>win</var>, <var>nfft</var>, <var>Fs</var>)</em><a href='#index-periodogram-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-periodogram-4"><span class="category">: </span><span><em>[<var>Pxx</var>, <var>f</var>] =</em> <strong>periodogram</strong> <em>(&hellip;, &quot;<var>range</var>&quot;)</em><a href='#index-periodogram-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-periodogram-5"><span class="category">: </span><span><em></em> <strong>periodogram</strong> <em>(&hellip;)</em><a href='#index-periodogram-5' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the periodogram (Power Spectral Density) of <var>x</var>.
</p>
<p>The possible inputs are:
</p>
<dl compact="compact">
<dt><span><var>x</var></span></dt>
<dd>
<p>data vector.  If <var>x</var> is real-valued a one-sided spectrum is estimated.
If <var>x</var> is complex-valued, or <code>&quot;<var>range</var>&quot;</code> specifies
<code>&quot;twosided&quot;</code>, the full spectrum is estimated.
</p>
</dd>
<dt><span><var>win</var></span></dt>
<dd><p>window weight data.  If window is empty or unspecified a default rectangular
window is used.  Otherwise, the window is applied to the signal
(<code><var>x</var> .* <var>win</var></code>) before computing the periodogram.  The window
data must be a vector of the same length as <var>x</var>.
</p>
</dd>
<dt><span><var>nfft</var></span></dt>
<dd><p>number of frequency bins.  The default is 256 or the next higher power of
2 greater than the length of <var>x</var>
(<code>max (256, 2.^nextpow2 (length (x)))</code>).  If <var>nfft</var> is greater
than the length of the input then <var>x</var> will be zero-padded to the length
of <var>nfft</var>.
</p>
</dd>
<dt><span><var>Fs</var></span></dt>
<dd><p>sampling rate.  The default is 1.
</p>
</dd>
<dt><span><var>range</var></span></dt>
<dd><p>range of spectrum.  <code>&quot;onesided&quot;</code> computes spectrum from
[0:nfft/2+1].  <code>&quot;twosided&quot;</code> computes spectrum from
[0:nfft-1].
</p></dd>
</dl>

<p>The optional second output <var>w</var> are the normalized angular frequencies.
For a one-sided calculation <var>w</var> is in the range [0, pi] if <var>nfft</var>
is even and [0, pi) if <var>nfft</var> is odd.  Similarly, for a two-sided
calculation <var>w</var> is in the range [0, 2*pi] or [0, 2*pi) depending on
<var>nfft</var>.
</p>
<p>If a sampling frequency is specified, <var>Fs</var>, then the output frequencies
<var>f</var> will be in the range [0, <var>Fs</var>/2] or [0, <var>Fs</var>/2) for
one-sided calculations.  For two-sided calculations the range will be
[0, <var>Fs</var>).
</p>
<p>When called with no outputs the periodogram is immediately plotted in the
current figure window.
</p>
<p><strong>See also:</strong> <a href="#XREFfft">fft</a>.
</p></dd></dl>


<span id="XREFsinetone"></span><dl class="def">
<dt id="index-sinetone"><span class="category">: </span><span><em></em> <strong>sinetone</strong> <em>(<var>freq</var>, <var>rate</var>, <var>sec</var>, <var>ampl</var>)</em><a href='#index-sinetone' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return a sinetone of frequency <var>freq</var> with a length of <var>sec</var>
seconds at sampling rate <var>rate</var> and with amplitude <var>ampl</var>.
</p>
<p>The arguments <var>freq</var> and <var>ampl</var> may be vectors of common size.
</p>
<p>The defaults are <var>rate</var> = 8000, <var>sec</var> = 1, and <var>ampl</var> = 64.
</p>
<p><strong>See also:</strong> <a href="#XREFsinewave">sinewave</a>.
</p></dd></dl>


<span id="XREFsinewave"></span><dl class="def">
<dt id="index-sinewave"><span class="category">: </span><span><em></em> <strong>sinewave</strong> <em>(<var>m</var>, <var>n</var>, <var>d</var>)</em><a href='#index-sinewave' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return an <var>m</var>-element vector with <var>i</var>-th element given by
<code>sin (2 * pi * (<var>i</var>+<var>d</var>-1) / <var>n</var>)</code>.
</p>
<p>The default value for <var>d</var> is 0 and the default value for <var>n</var> is
<var>m</var>.
</p>
<p><strong>See also:</strong> <a href="#XREFsinetone">sinetone</a>.
</p></dd></dl>


<span id="XREFspectral_005fadf"></span><dl class="def">
<dt id="index-spectral_005fadf"><span class="category">: </span><span><em></em> <strong>spectral_adf</strong> <em>(<var>c</var>)</em><a href='#index-spectral_005fadf' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-spectral_005fadf-1"><span class="category">: </span><span><em></em> <strong>spectral_adf</strong> <em>(<var>c</var>, <var>win</var>)</em><a href='#index-spectral_005fadf-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-spectral_005fadf-2"><span class="category">: </span><span><em></em> <strong>spectral_adf</strong> <em>(<var>c</var>, <var>win</var>, <var>b</var>)</em><a href='#index-spectral_005fadf-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the spectral density estimator given a vector of autocovariances
<var>c</var>, window name <var>win</var>, and bandwidth, <var>b</var>.
</p>
<p>The window name, e.g., <code>&quot;triangle&quot;</code> or <code>&quot;rectangle&quot;</code> is
used to search for a function called <code><var>win</var>_lw</code>.
</p>
<p>If <var>win</var> is omitted, the triangle window is used.
</p>
<p>If <var>b</var> is omitted, <code>1 / sqrt (length (<var>x</var>))</code> is used.
</p>
<p><strong>See also:</strong> <a href="#XREFspectral_005fxdf">spectral_xdf</a>.
</p></dd></dl>


<span id="XREFspectral_005fxdf"></span><dl class="def">
<dt id="index-spectral_005fxdf"><span class="category">: </span><span><em></em> <strong>spectral_xdf</strong> <em>(<var>x</var>)</em><a href='#index-spectral_005fxdf' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-spectral_005fxdf-1"><span class="category">: </span><span><em></em> <strong>spectral_xdf</strong> <em>(<var>x</var>, <var>win</var>)</em><a href='#index-spectral_005fxdf-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-spectral_005fxdf-2"><span class="category">: </span><span><em></em> <strong>spectral_xdf</strong> <em>(<var>x</var>, <var>win</var>, <var>b</var>)</em><a href='#index-spectral_005fxdf-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the spectral density estimator given a data vector <var>x</var>, window
name <var>win</var>, and bandwidth, <var>b</var>.
</p>
<p>The window name, e.g., <code>&quot;triangle&quot;</code> or <code>&quot;rectangle&quot;</code> is used to
search for a function called <code><var>win</var>_sw</code>.
</p>
<p>If <var>win</var> is omitted, the triangle window is used.
</p>
<p>If <var>b</var> is omitted, <code>1 / sqrt (length (<var>x</var>))</code> is used.
</p>
<p><strong>See also:</strong> <a href="#XREFspectral_005fadf">spectral_adf</a>.
</p></dd></dl>


<span id="XREFspencer"></span><dl class="def">
<dt id="index-spencer"><span class="category">: </span><span><em></em> <strong>spencer</strong> <em>(<var>x</var>)</em><a href='#index-spencer' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return Spencer&rsquo;s 15-point moving average of each column of
<var>x</var>.
</p></dd></dl>


<span id="XREFstft"></span><dl class="def">
<dt id="index-stft"><span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>)</em><a href='#index-stft' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-stft-1"><span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>)</em><a href='#index-stft-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-stft-2"><span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>, <var>inc</var>)</em><a href='#index-stft-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-stft-3"><span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>, <var>inc</var>, <var>num_coef</var>)</em><a href='#index-stft-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-stft-4"><span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>, <var>inc</var>, <var>num_coef</var>, <var>win_type</var>)</em><a href='#index-stft-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-stft-5"><span class="category">: </span><span><em>[<var>y</var>, <var>c</var>] =</em> <strong>stft</strong> <em>(&hellip;)</em><a href='#index-stft-5' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the short-time Fourier transform of the vector <var>x</var> with
<var>num_coef</var> coefficients by applying a window of <var>win_size</var> data
points and an increment of <var>inc</var> points.
</p>
<p>Before computing the Fourier transform, one of the following windows
is applied:
</p>
<dl compact="compact">
<dt><span><code>&quot;hanning&quot;</code></span></dt>
<dd><p>win_type = 1
</p>
</dd>
<dt><span><code>&quot;hamming&quot;</code></span></dt>
<dd><p>win_type = 2
</p>
</dd>
<dt><span><code>&quot;rectangle&quot;</code></span></dt>
<dd><p>win_type = 3
</p></dd>
</dl>

<p>The window names can be passed as strings or by the <var>win_type</var> number.
</p>
<p>The following defaults are used for unspecified arguments:
<var>win_size</var> = 80, <var>inc</var> = 24, <var>num_coef</var> = 64, and
<var>win_type</var> = 1.
</p>
<p><code><var>y</var> = stft (<var>x</var>, &hellip;)</code> returns the absolute values of the
Fourier coefficients according to the <var>num_coef</var> positive frequencies.
</p>
<p><code>[<var>y</var>, <var>c</var>] = stft (<var>x</var>, &hellip;)</code> returns the entire
STFT-matrix <var>y</var> and a 3-element vector <var>c</var> containing the window
size, increment, and window type, which is needed by the <code>synthesis</code>
function.
</p>
<p><strong>See also:</strong> <a href="#XREFsynthesis">synthesis</a>.
</p></dd></dl>


<span id="XREFsynthesis"></span><dl class="def">
<dt id="index-synthesis"><span class="category">: </span><span><em><var>x</var> =</em> <strong>synthesis</strong> <em>(<var>y</var>, <var>c</var>)</em><a href='#index-synthesis' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute a signal from its short-time Fourier transform <var>y</var> and a
3-element vector <var>c</var> specifying window size, increment, and window type.
</p>
<p>The values <var>y</var> and <var>c</var> can be derived by
</p>
<div class="example">
<pre class="example">[<var>y</var>, <var>c</var>] = stft (<var>x</var> , &hellip;)
</pre></div>

<p><strong>See also:</strong> <a href="#XREFstft">stft</a>.
</p></dd></dl>


<span id="XREFyulewalker"></span><dl class="def">
<dt id="index-yulewalker"><span class="category">: </span><span><em>[<var>a</var>, <var>v</var>] =</em> <strong>yulewalker</strong> <em>(<var>c</var>)</em><a href='#index-yulewalker' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Fit an AR (p)-model with Yule-Walker estimates given a vector <var>c</var> of
autocovariances <code>[gamma_0, &hellip;, gamma_p]</code>.
</p>
<p>Returns the AR coefficients, <var>a</var>, and the variance of white noise,
<var>v</var>.
</p></dd></dl>



</div>
<hr>
<div class="header">
<p>
Next: <a href="Image-Processing.html">Image Processing</a>, Previous: <a href="Geometry.html">Geometry</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
