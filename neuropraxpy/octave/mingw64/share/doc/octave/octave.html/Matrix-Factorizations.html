<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Matrix Factorizations (GNU Octave (version 7.2.0))</title>

<meta name="description" content="Matrix Factorizations (GNU Octave (version 7.2.0))">
<meta name="keywords" content="Matrix Factorizations (GNU Octave (version 7.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Linear-Algebra.html" rel="up" title="Linear Algebra">
<link href="Functions-of-a-Matrix.html" rel="next" title="Functions of a Matrix">
<link href="Basic-Matrix-Functions.html" rel="prev" title="Basic Matrix Functions">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section" id="Matrix-Factorizations">
<div class="header">
<p>
Next: <a href="Functions-of-a-Matrix.html" accesskey="n" rel="next">Functions of a Matrix</a>, Previous: <a href="Basic-Matrix-Functions.html" accesskey="p" rel="prev">Basic Matrix Functions</a>, Up: <a href="Linear-Algebra.html" accesskey="u" rel="up">Linear Algebra</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Matrix-Factorizations-1"></span><h3 class="section">18.3 Matrix Factorizations</h3>
<span id="index-matrix-factorizations"></span>

<span id="XREFchol"></span><dl class="def">
<dt id="index-chol"><span class="category">: </span><span><em><var>R</var> =</em> <strong>chol</strong> <em>(<var>A</var>)</em><a href='#index-chol' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-chol-1"><span class="category">: </span><span><em>[<var>R</var>, <var>p</var>] =</em> <strong>chol</strong> <em>(<var>A</var>)</em><a href='#index-chol-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-chol-2"><span class="category">: </span><span><em>[<var>R</var>, <var>p</var>, <var>Q</var>] =</em> <strong>chol</strong> <em>(<var>A</var>)</em><a href='#index-chol-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-chol-3"><span class="category">: </span><span><em>[<var>R</var>, <var>p</var>, <var>Q</var>] =</em> <strong>chol</strong> <em>(<var>A</var>, &quot;vector&quot;)</em><a href='#index-chol-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-chol-4"><span class="category">: </span><span><em>[<var>L</var>, &hellip;] =</em> <strong>chol</strong> <em>(&hellip;, &quot;lower&quot;)</em><a href='#index-chol-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-chol-5"><span class="category">: </span><span><em>[<var>R</var>, &hellip;] =</em> <strong>chol</strong> <em>(&hellip;, &quot;upper&quot;)</em><a href='#index-chol-5' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-Cholesky-factorization"></span>
<p>Compute the upper Cholesky&nbsp;factor, <var>R</var>, of the real symmetric
or complex Hermitian positive definite matrix <var>A</var>.
</p>
<p>The upper Cholesky&nbsp;factor <var>R</var> is computed by using the upper
triangular part of matrix <var>A</var> and is defined by
</p>
<div class="example">
<pre class="example"><var>R</var>' * <var>R</var> = <var>A</var>.
</pre></div>


<p>Calling <code>chol</code> using the optional <code>&quot;upper&quot;</code> flag has the
same behavior.  In contrast, using the optional <code>&quot;lower&quot;</code> flag,
<code>chol</code> returns the lower triangular factorization, computed by using
the lower triangular part of matrix <var>A</var>, such that
</p>
<div class="example">
<pre class="example"><var>L</var> * <var>L</var>' = <var>A</var>.
</pre></div>


<p>Called with one output argument <code>chol</code> fails if matrix <var>A</var> is
not positive definite.  Note that if matrix <var>A</var> is not real symmetric
or complex Hermitian then the lower triangular part is considered to be
the (complex conjugate) transpose of the upper triangular part, or vice
versa, given the <code>&quot;lower&quot;</code> flag.
</p>
<p>Called with two or more output arguments <var>p</var> flags whether the matrix
<var>A</var> was positive definite and <code>chol</code> does not fail.  A zero value
of <var>p</var> indicates that matrix <var>A</var> is positive definite and <var>R</var>
gives the factorization.  Otherwise, <var>p</var> will have a positive value.
</p>
<p>If called with three output arguments matrix <var>A</var> must be sparse and
a sparsity preserving row/column permutation is applied to matrix <var>A</var>
prior to the factorization.  That is <var>R</var> is the factorization of
<code><var>A</var>(<var>Q</var>,<var>Q</var>)</code> such that
</p>
<div class="example">
<pre class="example"><var>R</var>' * <var>R</var> = <var>Q</var>' * <var>A</var> * <var>Q</var>.
</pre></div>


<p>The sparsity preserving permutation is generally returned as a matrix.
However, given the optional flag <code>&quot;vector&quot;</code>, <var>Q</var> will be
returned as a vector such that
</p>
<div class="example">
<pre class="example"><var>R</var>' * <var>R</var> = <var>A</var>(<var>Q</var>, <var>Q</var>).
</pre></div>


<p>In general the lower triangular factorization is significantly faster for
sparse matrices.
</p>
<p><strong>See also:</strong> <a href="#XREFhess">hess</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>, <a href="Iterative-Techniques.html#XREFichol">ichol</a>, <a href="#XREFcholinv">cholinv</a>, <a href="#XREFchol2inv">chol2inv</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholdelete">choldelete</a>, <a href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<span id="XREFcholinv"></span><dl class="def">
<dt id="index-cholinv"><span class="category">: </span><span><em></em> <strong>cholinv</strong> <em>(<var>A</var>)</em><a href='#index-cholinv' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the inverse of the symmetric positive definite matrix <var>A</var> using
the Cholesky&nbsp;factorization.
</p>
<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFchol2inv">chol2inv</a>, <a href="Basic-Matrix-Functions.html#XREFinv">inv</a>.
</p></dd></dl>


<span id="XREFchol2inv"></span><dl class="def">
<dt id="index-chol2inv"><span class="category">: </span><span><em></em> <strong>chol2inv</strong> <em>(<var>U</var>)</em><a href='#index-chol2inv' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Invert a symmetric, positive definite square matrix from its Cholesky
decomposition, <var>U</var>.
</p>
<p>Note that <var>U</var> should be an upper-triangular matrix with positive
diagonal elements.  <code>chol2inv (<var>U</var>)</code> provides
<code>inv (<var>U</var>'*<var>U</var>)</code> but it is much faster than using <code>inv</code>.
</p>
<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholinv">cholinv</a>, <a href="Basic-Matrix-Functions.html#XREFinv">inv</a>.
</p></dd></dl>


<span id="XREFcholupdate"></span><dl class="def">
<dt id="index-cholupdate"><span class="category">: </span><span><em>[<var>R1</var>, <var>info</var>] =</em> <strong>cholupdate</strong> <em>(<var>R</var>, <var>u</var>, <var>op</var>)</em><a href='#index-cholupdate' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update or downdate a Cholesky&nbsp;factorization.
</p>
<p>Given an upper triangular matrix <var>R</var> and a column vector <var>u</var>,
attempt to determine another upper triangular matrix <var>R1</var> such that
</p>
<ul>
<li> <var>R1</var>&rsquo;*<var>R1</var> = <var>R</var>&rsquo;*<var>R</var> + <var>u</var>*<var>u</var>&rsquo;
if <var>op</var> is <code>&quot;+&quot;</code>

</li><li> <var>R1</var>&rsquo;*<var>R1</var> = <var>R</var>&rsquo;*<var>R</var> - <var>u</var>*<var>u</var>&rsquo;
if <var>op</var> is <code>&quot;-&quot;</code>
</li></ul>

<p>If <var>op</var> is <code>&quot;-&quot;</code>, <var>info</var> is set to
</p>
<ul>
<li> 0 if the downdate was successful,

</li><li> 1 if <var>R</var>&rsquo;*<var>R</var> - <var>u</var>*<var>u</var>&rsquo; is not positive definite,

</li><li> 2 if <var>R</var> is singular.
</li></ul>

<p>If <var>info</var> is not present, an error message is printed in cases 1 and 2.
</p>
<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholdelete">choldelete</a>, <a href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<span id="XREFcholinsert"></span><dl class="def">
<dt id="index-cholinsert"><span class="category">: </span><span><em><var>R1</var> =</em> <strong>cholinsert</strong> <em>(<var>R</var>, <var>j</var>, <var>u</var>)</em><a href='#index-cholinsert' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-cholinsert-1"><span class="category">: </span><span><em>[<var>R1</var>, <var>info</var>] =</em> <strong>cholinsert</strong> <em>(<var>R</var>, <var>j</var>, <var>u</var>)</em><a href='#index-cholinsert-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a Cholesky factorization given a row or column to insert in the
original factored matrix.
</p>
<p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var>A</var>&nbsp;=&nbsp;<var>R</var>&rsquo;*<var>R</var><!-- /@w -->, <var>R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of
<var>A1</var>, where A1(p,p)&nbsp;=&nbsp;A<!-- /@w -->, A1(:,j)&nbsp;=&nbsp;A1(j,:)&rsquo;&nbsp;=&nbsp;u<!-- /@w --> and
p&nbsp;=&nbsp;<span class="nolinebreak">[1:j-1,j+1:n+1]</span><!-- /@w -->.  u(j)<!-- /@w --> should be positive.
</p>
<p>On return, <var>info</var> is set to
</p>
<ul>
<li> 0 if the insertion was successful,

</li><li> 1 if <var>A1</var> is not positive definite,

</li><li> 2 if <var>R</var> is singular.
</li></ul>

<p>If <var>info</var> is not present, an error message is printed in cases 1 and 2.
</p>
<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholdelete">choldelete</a>, <a href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<span id="XREFcholdelete"></span><dl class="def">
<dt id="index-choldelete"><span class="category">: </span><span><em><var>R1</var> =</em> <strong>choldelete</strong> <em>(<var>R</var>, <var>j</var>)</em><a href='#index-choldelete' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a Cholesky factorization given a row or column to delete from the
original factored matrix.
</p>
<p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var>A</var>&nbsp;=&nbsp;<var>R</var>&rsquo;*<var>R</var><!-- /@w -->, <var>R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of A(p,p)<!-- /@w -->, where
p&nbsp;=&nbsp;<span class="nolinebreak">[1:j-1,j+1:n+1]</span><!-- /@w -->.
</p>
<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<span id="XREFcholshift"></span><dl class="def">
<dt id="index-cholshift"><span class="category">: </span><span><em><var>R1</var> =</em> <strong>cholshift</strong> <em>(<var>R</var>, <var>i</var>, <var>j</var>)</em><a href='#index-cholshift' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a Cholesky factorization given a range of columns to shift in the
original factored matrix.
</p>
<p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var>A</var>&nbsp;=&nbsp;<var>R</var>&rsquo;*<var>R</var><!-- /@w -->, <var>R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of
<var>A</var>(p,p)<!-- /@w -->, where p<!-- /@w --> is the permutation <br>
<code>p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var>i</var>&nbsp;&lt;&nbsp;<var>j</var><!-- /@w --> <br>
 or <br>
<code>p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var>j</var>&nbsp;&lt;&nbsp;<var>i</var><!-- /@w -->.  <br>
</p>

<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholdelete">choldelete</a>.
</p></dd></dl>


<span id="XREFhess"></span><dl class="def">
<dt id="index-hess"><span class="category">: </span><span><em><var>H</var> =</em> <strong>hess</strong> <em>(<var>A</var>)</em><a href='#index-hess' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-hess-1"><span class="category">: </span><span><em>[<var>P</var>, <var>H</var>] =</em> <strong>hess</strong> <em>(<var>A</var>)</em><a href='#index-hess-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-Hessenberg-decomposition"></span>
<p>Compute the Hessenberg decomposition of the matrix <var>A</var>.
</p>
<p>The Hessenberg decomposition is
<code><var>P</var> * <var>H</var> * <var>P</var>' = <var>A</var></code> where <var>P</var> is a square
unitary matrix (<code><var>P</var>' * <var>P</var> = I</code>, using complex-conjugate
transposition) and <var>H</var> is upper Hessenberg
(<code><var>H</var>(i, j) = 0 forall i &gt; j+1)</code>.
</p>
<p>The Hessenberg decomposition is usually used as the first step in an
eigenvalue computation, but has other applications as well
(see Golub, Nash, and Van Loan,
IEEE Transactions on Automatic Control, 1979).
</p>
<p><strong>See also:</strong> <a href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a href="#XREFchol">chol</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>.
</p></dd></dl>


<span id="XREFlu"></span><dl class="def">
<dt id="index-lu"><span class="category">: </span><span><em>[<var>L</var>, <var>U</var>] =</em> <strong>lu</strong> <em>(<var>A</var>)</em><a href='#index-lu' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-lu-1"><span class="category">: </span><span><em>[<var>L</var>, <var>U</var>, <var>P</var>] =</em> <strong>lu</strong> <em>(<var>A</var>)</em><a href='#index-lu-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-lu-2"><span class="category">: </span><span><em>[<var>L</var>, <var>U</var>, <var>P</var>, <var>Q</var>] =</em> <strong>lu</strong> <em>(<var>S</var>)</em><a href='#index-lu-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-lu-3"><span class="category">: </span><span><em>[<var>L</var>, <var>U</var>, <var>P</var>, <var>Q</var>, <var>R</var>] =</em> <strong>lu</strong> <em>(<var>S</var>)</em><a href='#index-lu-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-lu-4"><span class="category">: </span><span><em>[&hellip;] =</em> <strong>lu</strong> <em>(<var>S</var>, <var>thresh</var>)</em><a href='#index-lu-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-lu-5"><span class="category">: </span><span><em><var>y</var> =</em> <strong>lu</strong> <em>(&hellip;)</em><a href='#index-lu-5' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-lu-6"><span class="category">: </span><span><em>[&hellip;] =</em> <strong>lu</strong> <em>(&hellip;, &quot;vector&quot;)</em><a href='#index-lu-6' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-LU-decomposition"></span>
<p>Compute the LU&nbsp;decomposition of <var>A</var>.
</p>
<p>If <var>A</var> is full then subroutines from <small>LAPACK</small> are used, and if
<var>A</var> is sparse then <small>UMFPACK</small> is used.
</p>
<p>The result is returned in a permuted form, according to the optional return
value <var>P</var>.  For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>,
</p>
<div class="example">
<pre class="example">[<var>L</var>, <var>U</var>, <var>P</var>] = lu (<var>A</var>)
</pre></div>

<p>returns
</p>
<div class="example">
<pre class="example">L =

  1.00000  0.00000
  0.33333  1.00000

U =

  3.00000  4.00000
  0.00000  0.66667

P =

  0  1
  1  0
</pre></div>

<p>The matrix is not required to be square.
</p>
<p>When called with two or three output arguments and a sparse input matrix,
<code>lu</code> does not attempt to perform sparsity preserving column permutations.
Called with a fourth output argument, the sparsity preserving column
transformation <var>Q</var> is returned, such that
<code><var>P</var> * <var>A</var> * <var>Q</var> = <var>L</var> * <var>U</var></code>.  This is the
<strong>preferred</strong> way to call <code>lu</code> with sparse input matrices.
</p>
<p>Called with a fifth output argument and a sparse input matrix, <code>lu</code>
attempts to use a scaling factor <var>R</var> on the input matrix such that
<code><var>P</var> * (<var>R</var> \ <var>A</var>) * <var>Q</var> = <var>L</var> * <var>U</var></code>.
This typically leads to a sparser and more stable factorization.
</p>
<p>An additional input argument <var>thresh</var> that defines the pivoting
threshold can be given.  <var>thresh</var> can be a scalar, in which case
it defines the <small>UMFPACK</small> pivoting tolerance for both symmetric and
unsymmetric cases.  If <var>thresh</var> is a 2-element vector, then the first
element defines the pivoting tolerance for the unsymmetric <small>UMFPACK</small>
pivoting strategy and the second for the symmetric strategy.  By default,
the values defined by <code>spparms</code> are used ([0.1, 0.001]).
</p>
<p>Given the string argument <code>&quot;vector&quot;</code>, <code>lu</code> returns the values
of <var>P</var> and <var>Q</var> as vector values, such that for full matrix,
<code><var>A</var>(<var>P</var>,:) = <var>L</var> * <var>U</var></code>, and <code><var>R</var>(<var>P</var>,:)
* <var>A</var>(:,<var>Q</var>) = <var>L</var> * <var>U</var></code>.
</p>
<p>With two output arguments, returns the permuted forms of the upper and
lower triangular matrices, such that <code><var>A</var> = <var>L</var> * <var>U</var></code>.
With one output argument <var>y</var>, then the matrix returned by the
<small>LAPACK</small> routines is returned.  If the input matrix is sparse then the
matrix <var>L</var> is embedded into <var>U</var> to give a return value similar to
the full case.  For both full and sparse matrices, <code>lu</code> loses the
permutation information.
</p>
<p><strong>See also:</strong> <a href="#XREFluupdate">luupdate</a>, <a href="Iterative-Techniques.html#XREFilu">ilu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>.
</p></dd></dl>


<span id="XREFluupdate"></span><dl class="def">
<dt id="index-luupdate"><span class="category">: </span><span><em>[<var>L</var>, <var>U</var>] =</em> <strong>luupdate</strong> <em>(<var>L</var>, <var>U</var>, <var>x</var>, <var>y</var>)</em><a href='#index-luupdate' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-luupdate-1"><span class="category">: </span><span><em>[<var>L</var>, <var>U</var>, <var>P</var>] =</em> <strong>luupdate</strong> <em>(<var>L</var>, <var>U</var>, <var>P</var>, <var>x</var>, <var>y</var>)</em><a href='#index-luupdate-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Given an LU&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>L</var>*<var>U</var><!-- /@w -->, <var>L</var>&nbsp;lower unit trapezoidal and
<var>U</var>&nbsp;upper trapezoidal, return the LU&nbsp;factorization
of <var>A</var>&nbsp;+&nbsp;<var>x</var>*<var>y</var>.&rsquo;<!-- /@w -->, where <var>x</var> and <var>y</var> are
column vectors (rank-1 update) or matrices with equal number of columns
(rank-k update).
</p>
<p>Optionally, row-pivoted updating can be used by supplying a row permutation
(pivoting) matrix <var>P</var>; in that case, an updated permutation matrix is
returned.  Note that if <var>L</var>, <var>U</var>, <var>P</var> is a pivoted
LU&nbsp;factorization as obtained by <code>lu</code>:
</p>
<div class="example">
<pre class="example">[<var>L</var>, <var>U</var>, <var>P</var>] = lu (<var>A</var>);
</pre></div>

<p>then a factorization of <code><var>A</var>+<var>x</var>*<var>y</var>.'</code> can be obtained
either as
</p>
<div class="example">
<pre class="example">[<var>L1</var>, <var>U1</var>] = lu (<var>L</var>, <var>U</var>, <var>P</var>*<var>x</var>, <var>y</var>)
</pre></div>

<p>or
</p>
<div class="example">
<pre class="example">[<var>L1</var>, <var>U1</var>, <var>P1</var>] = lu (<var>L</var>, <var>U</var>, <var>P</var>, <var>x</var>, <var>y</var>)
</pre></div>

<p>The first form uses the unpivoted algorithm, which is faster, but less
stable.  The second form uses a slower pivoted algorithm, which is more
stable.
</p>
<p>The matrix case is done as a sequence of rank-1 updates; thus, for large
enough k, it will be both faster and more accurate to recompute the
factorization from scratch.
</p>
<p><strong>See also:</strong> <a href="#XREFlu">lu</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFqrupdate">qrupdate</a>.
</p></dd></dl>


<span id="XREFqr"></span><dl class="def">
<dt id="index-qr"><span class="category">: </span><span><em>[<var>Q</var>, <var>R</var>] =</em> <strong>qr</strong> <em>(<var>A</var>)</em><a href='#index-qr' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-1"><span class="category">: </span><span><em>[<var>Q</var>, <var>R</var>, <var>P</var>] =</em> <strong>qr</strong> <em>(<var>A</var>)</em><a href='#index-qr-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-2"><span class="category">: </span><span><em><var>X</var> =</em> <strong>qr</strong> <em>(<var>A</var>)  # non-sparse A</em><a href='#index-qr-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-3"><span class="category">: </span><span><em><var>R</var> =</em> <strong>qr</strong> <em>(<var>A</var>)  # sparse A</em><a href='#index-qr-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-4"><span class="category">: </span><span><em><var>X</var> =</em> <strong>qr</strong> <em>(<var>A</var>, <var>B</var>) # sparse A</em><a href='#index-qr-4' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-5"><span class="category">: </span><span><em>[<var>C</var>, <var>R</var>] =</em> <strong>qr</strong> <em>(<var>A</var>, <var>B</var>)</em><a href='#index-qr-5' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-6"><span class="category">: </span><span><em>[&hellip;] =</em> <strong>qr</strong> <em>(&hellip;, 0)</em><a href='#index-qr-6' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-7"><span class="category">: </span><span><em>[&hellip;] =</em> <strong>qr</strong> <em>(&hellip;, &quot;vector&quot;)</em><a href='#index-qr-7' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qr-8"><span class="category">: </span><span><em>[&hellip;] =</em> <strong>qr</strong> <em>(&hellip;, &quot;matrix&quot;)</em><a href='#index-qr-8' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-QR-factorization"></span>
<p>Compute the QR&nbsp;factorization of <var>A</var>, using standard <small>LAPACK</small>
subroutines.
</p>
<p>The QR&nbsp;factorization is
</p>
<div class="example">
<pre class="example"><var>Q</var> * <var>R</var> = <var>A</var>
</pre></div>

<p>where <var>Q</var> is an orthogonal matrix and <var>R</var> is upper triangular.
</p>
<p>For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>,
</p>
<div class="example">
<pre class="example">[<var>Q</var>, <var>R</var>] = qr (<var>A</var>)
</pre></div>

<p>returns
</p>
<div class="example">
<pre class="example"><var>Q</var> =

  -0.31623  -0.94868
  -0.94868   0.31623

<var>R</var> =

  -3.16228  -4.42719
   0.00000  -0.63246
</pre></div>

<p>which multiplied together return the original matrix
</p>
<div class="example">
<pre class="example"><var>Q</var> * <var>R</var>
  &rArr;
     1.0000   2.0000
     3.0000   4.0000
</pre></div>

<p>If just a single return value is requested then it is either <var>R</var>, if
<var>A</var> is sparse, or <var>X</var>, such that <code><var>R</var> = triu (<var>X</var>)</code> if
<var>A</var> is full.  (Note: unlike most commands, the single return value is not
the first return value when multiple values are requested.)
</p>
<p>If a third output <var>P</var> is requested, then <code>qr</code> calculates the permuted
QR&nbsp;factorization
</p>
<div class="example">
<pre class="example"><var>Q</var> * <var>R</var> = <var>A</var> * <var>P</var>
</pre></div>

<p>where <var>Q</var> is an orthogonal matrix, <var>R</var> is upper triangular, and
<var>P</var> is a permutation matrix.
</p>
<p>If <var>A</var> is dense, the permuted QR&nbsp;factorization has the additional
property that the diagonal entries of <var>R</var> are ordered by decreasing
magnitude.  In other words, <code>abs (diag (<var>R</var>))</code> will be ordered
from largest to smallest.
</p>
<p>If <var>A</var> is sparse, <var>P</var> is a fill-reducing ordering of the columns
of <var>A</var>.  In that case, the diagonal entries of <var>R</var> are not ordered by
decreasing magnitude.
</p>
<p>For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>,
</p>
<div class="example">
<pre class="example">[<var>Q</var>, <var>R</var>, <var>P</var>] = qr (<var>A</var>)
</pre></div>

<p>returns
</p>
<div class="example">
<pre class="example"><var>Q</var> =

  -0.44721  -0.89443
  -0.89443   0.44721

<var>R</var> =

  -4.47214  -3.13050
   0.00000   0.44721

<var>P</var> =

   0  1
   1  0
</pre></div>

<p>If the input matrix <var>A</var> is sparse, the sparse QR&nbsp;factorization
is computed by using <small>SPQR</small> or <small>CXSPARSE</small> (e.g., if <small>SPQR</small> is not
available).  Because the matrix <var>Q</var> is, in general, a full matrix, it is
recommended to request only one return value <var>R</var>.  In that case, the
computation avoids the construction of <var>Q</var> and returns a sparse <var>R</var>
such that <code><var>R</var> = chol (<var>A</var>' * <var>A</var>)</code>.
</p>
<p>If <var>A</var> is dense, an additional matrix <var>B</var> is supplied and two
return values are requested, then <code>qr</code> returns <var>C</var>, where
<code><var>C</var> = <var>Q</var>' * <var>B</var></code>.  This allows the least squares
approximation of <code><var>A</var> \ <var>B</var></code> to be calculated as
</p>
<div class="example">
<pre class="example">[<var>C</var>, <var>R</var>] = qr (<var>A</var>, <var>B</var>)
<var>X</var> = <var>R</var> \ <var>C</var>
</pre></div>

<p>If <var>A</var> is a sparse MxN matrix and an additional matrix <var>B</var> is
supplied, one or two return values are possible.  If one return value <var>X</var>
is requested and M &lt; N, then <var>X</var> is the minimum 2-norm solution of
<code><var>A</var>&nbsp;\&nbsp;<var>B</var></code><!-- /@w -->.  If M &gt;= N, <var>X</var> is the least squares
approximation of&nbsp;<code><var>A</var>&nbsp;\&nbsp;<var>B</var></code><!-- /@w -->.  If two return values are
requested, <var>C</var> and <var>R</var> have the same meaning as in the dense case
(<var>C</var> is dense and <var>R</var> is sparse).
The version with one return parameter should be preferred because
it uses less memory and can handle rank-deficient matrices better.
</p>
<p>If the final argument is the string <code>&quot;vector&quot;</code> then <var>P</var> is a
permutation vector (of the columns of <var>A</var>) instead of a permutation
matrix.  In this case, the defining relationship is:
</p>
<div class="example">
<pre class="example"><var>Q</var> * <var>R</var> = <var>A</var>(:, <var>P</var>)
</pre></div>

<p>The default, however, is to return a permutation matrix and this may be
explicitly specified by using a final argument of <code>&quot;matrix&quot;</code>.
</p>
<p>If the final argument is the scalar 0 an <code>&quot;economy&quot;</code> factorization is
returned.  If the original matrix <var>A</var> has size MxN and M &gt; N, then the
<code>&quot;economy&quot;</code> factorization will calculate just N rows in <var>R</var> and N
columns in <var>Q</var> and omit the zeros in <var>R</var>.  If M &le; N, there is no
difference between the economy and standard factorizations.  When calculating
an <code>&quot;economy&quot;</code> factorization and <var>A</var> is dense, the output <var>P</var> is
always a vector rather than a matrix.  If <var>A</var> is sparse, output
<var>P</var> is a sparse permutation matrix.
</p>
<p>Background: The QR factorization has applications in the solution of least
squares problems
</p>
<div class="example">
<pre class="example">min norm (A*x - b)
</pre></div>

<p>for overdetermined systems of equations (i.e.,
<var>A</var>
is a tall, thin matrix).
</p>
<p>The permuted QR&nbsp;factorization
<code>[<var>Q</var>, <var>R</var>, <var>P</var>] = qr (<var>A</var>)</code> allows the construction of an
orthogonal basis of <code>span (A)</code>.
</p>

<p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrdelete">qrdelete</a>, <a href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<span id="XREFqrupdate"></span><dl class="def">
<dt id="index-qrupdate"><span class="category">: </span><span><em>[<var>Q1</var>, <var>R1</var>] =</em> <strong>qrupdate</strong> <em>(<var>Q</var>, <var>R</var>, <var>u</var>, <var>v</var>)</em><a href='#index-qrupdate' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a QR factorization given update vectors or matrices.
</p>
<p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
<var>A</var>&nbsp;+&nbsp;<var>u</var>*<var>v</var>&rsquo;<!-- /@w -->, where <var>u</var> and <var>v</var> are column vectors
(rank-1 update) or matrices with equal number of columns
(rank-k update).  Notice that the latter case is done as a sequence of
rank-1 updates; thus, for k large enough, it will be both faster and more
accurate to recompute the factorization from scratch.
</p>
<p>The QR&nbsp;factorization supplied may be either full (Q is square) or
economized (R is square).
</p>

<p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrdelete">qrdelete</a>, <a href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<span id="XREFqrinsert"></span><dl class="def">
<dt id="index-qrinsert"><span class="category">: </span><span><em>[<var>Q1</var>, <var>R1</var>] =</em> <strong>qrinsert</strong> <em>(<var>Q</var>, <var>R</var>, <var>j</var>, <var>x</var>, <var>orient</var>)</em><a href='#index-qrinsert' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a QR factorization given a row or column to insert in the original
factored matrix.
</p>

<p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
<span class="nolinebreak">[A(:,1:j-1)</span>&nbsp;x&nbsp;A(:,j:n)]<!-- /@w -->, where <var>u</var> is a column vector to be inserted
into <var>A</var> (if <var>orient</var> is <code>&quot;col&quot;</code>), or the
QR&nbsp;factorization of <span class="nolinebreak">[A(1:j-1,:);x;A(:,j:n)]</span><!-- /@w -->, where <var>x</var> is a row
vector to be inserted into <var>A</var> (if <var>orient</var> is <code>&quot;row&quot;</code>).
</p>
<p>The default value of <var>orient</var> is <code>&quot;col&quot;</code>.  If <var>orient</var> is
<code>&quot;col&quot;</code>, <var>u</var> may be a matrix and <var>j</var> an index vector
resulting in the QR&nbsp;factorization of a matrix <var>B</var> such that
B(:,<var>j</var>)<!-- /@w --> gives <var>u</var> and B(:,<var>j</var>)&nbsp;=&nbsp;[]<!-- /@w --> gives <var>A</var>.
Notice that the latter case is done as a sequence of k insertions;
thus, for k large enough, it will be both faster and more accurate to
recompute the factorization from scratch.
</p>
<p>If <var>orient</var> is <code>&quot;col&quot;</code>, the QR&nbsp;factorization supplied may
be either full (Q is square) or economized (R is square).
</p>
<p>If <var>orient</var> is <code>&quot;row&quot;</code>, full factorization is needed.
</p>
<p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrdelete">qrdelete</a>, <a href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<span id="XREFqrdelete"></span><dl class="def">
<dt id="index-qrdelete"><span class="category">: </span><span><em>[<var>Q1</var>, <var>R1</var>] =</em> <strong>qrdelete</strong> <em>(<var>Q</var>, <var>R</var>, <var>j</var>, <var>orient</var>)</em><a href='#index-qrdelete' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a QR factorization given a row or column to delete from the original
factored matrix.
</p>
<p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
<span class="nolinebreak">[A(:,1:j-1),</span>&nbsp;U,&nbsp;A(:,j:n)]<!-- /@w -->,
where <var>u</var> is a column vector to be inserted into <var>A</var>
(if <var>orient</var> is <code>&quot;col&quot;</code>),
or the QR&nbsp;factorization of <span class="nolinebreak">[A(1:j-1,:);X;A(:,j:n)]</span><!-- /@w -->,
where <var>x</var> is a row <var>orient</var> is <code>&quot;row&quot;</code>).
The default value of <var>orient</var> is <code>&quot;col&quot;</code>.
</p>
<p>If <var>orient</var> is <code>&quot;col&quot;</code>, <var>j</var> may be an index vector
resulting in the QR&nbsp;factorization of a matrix <var>B</var> such that
A(:,<var>j</var>)&nbsp;=&nbsp;[]<!-- /@w --> gives <var>B</var>.  Notice that the latter case is done as
a sequence of k deletions; thus, for k large enough, it will be both faster
and more accurate to recompute the factorization from scratch.
</p>
<p>If <var>orient</var> is <code>&quot;col&quot;</code>, the QR&nbsp;factorization supplied may
be either full (Q is square) or economized (R is square).
</p>
<p>If <var>orient</var> is <code>&quot;row&quot;</code>, full factorization is needed.
</p>
<p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<span id="XREFqrshift"></span><dl class="def">
<dt id="index-qrshift"><span class="category">: </span><span><em>[<var>Q1</var>, <var>R1</var>] =</em> <strong>qrshift</strong> <em>(<var>Q</var>, <var>R</var>, <var>i</var>, <var>j</var>)</em><a href='#index-qrshift' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Update a QR factorization given a range of columns to shift in the original
factored matrix.
</p>
<p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization
of <var>A</var>(:,p)<!-- /@w -->, where p<!-- /@w --> is the permutation <br>
<code>p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var>i</var>&nbsp;&lt;&nbsp;<var>j</var><!-- /@w --> <br>
 or <br>
<code>p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var>j</var>&nbsp;&lt;&nbsp;<var>i</var><!-- /@w -->.  <br>
</p>

<p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrdelete">qrdelete</a>.
</p></dd></dl>


<span id="XREFqz"></span><dl class="def">
<dt id="index-qz"><span class="category">: </span><span><em><var>lambda</var> =</em> <strong>qz</strong> <em>(<var>A</var>, <var>B</var>)</em><a href='#index-qz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qz-1"><span class="category">: </span><span><em>[<var>AA</var>, <var>BB</var>, <var>Q</var>, <var>Z</var>, <var>V</var>, <var>W</var>, <var>lambda</var>] =</em> <strong>qz</strong> <em>(<var>A</var>, <var>B</var>)</em><a href='#index-qz-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qz-2"><span class="category">: </span><span><em>[<var>AA</var>, <var>BB</var>, <var>Z</var>] =</em> <strong>qz</strong> <em>(<var>A</var>, <var>B</var>, <var>opt</var>)</em><a href='#index-qz-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-qz-3"><span class="category">: </span><span><em>[<var>AA</var>, <var>BB</var>, <var>Z</var>, <var>lambda</var>] =</em> <strong>qz</strong> <em>(<var>A</var>, <var>B</var>, <var>opt</var>)</em><a href='#index-qz-3' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the QZ&nbsp;decomposition of a generalized eigenvalue problem.
</p>
<p>The generalized eigenvalue problem is defined as
</p>

<p><em class='math'>A x = <var>lambda</var> B x</em>
</p>

<p>There are three calling forms of the function:
</p>
<ol>
<li> <code><var>lambda</var> = qz (<var>A</var>, <var>B</var>)</code>

<p>Compute the generalized eigenvalues
<var>lambda</var>.
</p>
</li><li> <code>[<var>AA</var>, <var>BB</var>, <var>Q</var>, <var>Z</var>, <var>V</var>, <var>W</var>, <var>lambda</var>] = qz (<var>A</var>, <var>B</var>)</code>

<p>Compute QZ&nbsp;decomposition, generalized eigenvectors, and generalized
eigenvalues.
</p>
<div class="example">
<pre class="example">

<var>AA</var> = <var>Q</var> * <var>A</var> * <var>Z</var>, <var>BB</var> = <var>Q</var> * <var>B</var> * <var>Z</var>
<var>A</var> * <var>V</var> = <var>B</var> * <var>V</var> * diag (<var>lambda</var>)
<var>W</var>' * <var>A</var> = diag (<var>lambda</var>) * <var>W</var>' * <var>B</var>

</pre></div>

<p>with <var>Q</var> and <var>Z</var> orthogonal (unitary for complex case).
</p>
</li><li> <code>[<var>AA</var>, <var>BB</var>, <var>Z</var> {, <var>lambda</var>}] = qz (<var>A</var>, <var>B</var>, <var>opt</var>)</code>

<p>As in form 2 above, but allows ordering of generalized eigenpairs for, e.g.,
solution of discrete time algebraic Riccati equations.  Form 3 is not
available for complex matrices, and does not compute the generalized
eigenvectors <var>V</var>, <var>W</var>, nor the orthogonal matrix <var>Q</var>.
</p>
<dl compact="compact">
<dt><span><var>opt</var></span></dt>
<dd><p>for ordering eigenvalues of the GEP pencil.  The leading block of
the revised pencil contains all eigenvalues that satisfy:
</p>
<dl compact="compact">
<dt><span><code>&quot;N&quot;</code></span></dt>
<dd><p>unordered (default)
</p>
</dd>
<dt><span><code>&quot;S&quot;</code></span></dt>
<dd><p>small: leading block has all
|<var>lambda</var>| &lt; 1
</p>
</dd>
<dt><span><code>&quot;B&quot;</code></span></dt>
<dd><p>big: leading block has all
|<var>lambda</var>| &ge; 1
</p>
</dd>
<dt><span><code>&quot;-&quot;</code></span></dt>
<dd><p>negative real part: leading block has all eigenvalues in the open left
half-plane
</p>
</dd>
<dt><span><code>&quot;+&quot;</code></span></dt>
<dd><p>non-negative real part: leading block has all eigenvalues in the closed right
half-plane
</p></dd>
</dl>
</dd>
</dl>
</li></ol>

<p>Note: <code>qz</code> performs permutation balancing, but not scaling
(see <a href="Basic-Matrix-Functions.html#XREFbalance"><code>balance</code></a>), which may be lead to less accurate
results than <code>eig</code>.  The order of output arguments was selected for
compatibility with <small>MATLAB</small>.
</p>
<p><strong>See also:</strong> <a href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a href="Basic-Matrix-Functions.html#XREFgsvd">gsvd</a>, <a href="Basic-Matrix-Functions.html#XREFbalance">balance</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqzhess">qzhess</a>, <a href="#XREFschur">schur</a>.
</p></dd></dl>


<span id="XREFqzhess"></span><dl class="def">
<dt id="index-qzhess"><span class="category">: </span><span><em>[<var>aa</var>, <var>bb</var>, <var>q</var>, <var>z</var>] =</em> <strong>qzhess</strong> <em>(<var>A</var>, <var>B</var>)</em><a href='#index-qzhess' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute the Hessenberg-triangular decomposition of the matrix pencil
<code>(<var>A</var>, <var>B</var>)</code>, returning
<code><var>aa</var> = <var>q</var> * <var>A</var> * <var>z</var></code>,
<code><var>bb</var> = <var>q</var> * <var>B</var> * <var>z</var></code>, with <var>q</var> and <var>z</var>
orthogonal.
</p>
<p>For example:
</p>
<div class="example">
<pre class="example">[aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
  &rArr; aa =
      -3.02244  -4.41741
       0.92998   0.69749
  &rArr; bb =
      -8.60233  -9.99730
       0.00000  -0.23250
  &rArr; q =
      -0.58124  -0.81373
      -0.81373   0.58124
  &rArr; z =
     Diagonal Matrix
       1   0
       0   1
</pre></div>

<p>The Hessenberg-triangular decomposition is the first step in
Moler and Stewart&rsquo;s QZ&nbsp;decomposition algorithm.
</p>
<p>Algorithm taken from Golub and Van Loan,
<cite>Matrix Computations, 2nd edition</cite>.
</p>

<p><strong>See also:</strong> <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>.
</p></dd></dl>


<span id="XREFschur"></span><dl class="def">
<dt id="index-schur"><span class="category">: </span><span><em><var>S</var> =</em> <strong>schur</strong> <em>(<var>A</var>)</em><a href='#index-schur' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-schur-1"><span class="category">: </span><span><em><var>S</var> =</em> <strong>schur</strong> <em>(<var>A</var>, &quot;real&quot;)</em><a href='#index-schur-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-schur-2"><span class="category">: </span><span><em><var>S</var> =</em> <strong>schur</strong> <em>(<var>A</var>, &quot;complex&quot;)</em><a href='#index-schur-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-schur-3"><span class="category">: </span><span><em><var>S</var> =</em> <strong>schur</strong> <em>(<var>A</var>, <var>opt</var>)</em><a href='#index-schur-3' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-schur-4"><span class="category">: </span><span><em>[<var>U</var>, <var>S</var>] =</em> <strong>schur</strong> <em>(&hellip;)</em><a href='#index-schur-4' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-Schur-decomposition"></span>
<p>Compute the Schur&nbsp;decomposition of <var>A</var>.
</p>
<p>The Schur&nbsp;decomposition is defined as
</p>
<div class="example">
<pre class="example"><code><var>S</var> = <var>U</var>' * <var>A</var> * <var>U</var></code>
</pre></div>

<p>where <var>U</var> is a unitary matrix
(<code><var>U</var>'* <var>U</var></code> is identity)
and <var>S</var> is upper triangular.  The eigenvalues of <var>A</var> (and <var>S</var>)
are the diagonal elements of <var>S</var>.  If the matrix <var>A</var> is real, then
the real Schur&nbsp;decomposition is computed, in which the matrix <var>U</var>
is orthogonal and <var>S</var> is block upper triangular with blocks of size at
most
<code>2 x 2</code>
along the diagonal.  The diagonal elements of <var>S</var>
(or the eigenvalues of the
<code>2 x 2</code>
blocks, when appropriate) are the eigenvalues of <var>A</var> and <var>S</var>.
</p>
<p>The default for real matrices is a real Schur&nbsp;decomposition.
A complex decomposition may be forced by passing the flag
<code>&quot;complex&quot;</code>.
</p>
<p>The eigenvalues are optionally ordered along the diagonal according to the
value of <var>opt</var>.  <code><var>opt</var> = &quot;a&quot;</code> indicates that all eigenvalues
with negative real parts should be moved to the leading block of <var>S</var>
(used in <code>are</code>), <code><var>opt</var> = &quot;d&quot;</code> indicates that all
eigenvalues with magnitude less than one should be moved to the leading
block of <var>S</var> (used in <code>dare</code>), and <code><var>opt</var> = &quot;u&quot;</code>, the
default, indicates that no ordering of eigenvalues should occur.  The
leading <var>k</var> columns of <var>U</var> always span the <var>A</var>-invariant
subspace corresponding to the <var>k</var> leading eigenvalues of <var>S</var>.
</p>
<p>The Schur&nbsp;decomposition is used to compute eigenvalues of a square
matrix, and has applications in the solution of algebraic Riccati
equations in control (see <code>are</code> and <code>dare</code>).
</p>
<p><strong>See also:</strong> <a href="#XREFrsf2csf">rsf2csf</a>, <a href="#XREFordschur">ordschur</a>, <a href="#XREFordeig">ordeig</a>, <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFsvd">svd</a>.
</p></dd></dl>


<span id="XREFrsf2csf"></span><dl class="def">
<dt id="index-rsf2csf"><span class="category">: </span><span><em>[<var>U</var>, <var>T</var>] =</em> <strong>rsf2csf</strong> <em>(<var>UR</var>, <var>TR</var>)</em><a href='#index-rsf2csf' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert a real, upper quasi-triangular Schur&nbsp;form <var>TR</var> to a
complex, upper triangular Schur&nbsp;form <var>T</var>.
</p>
<p>Note that the following relations hold:
</p>
<p><code><var>UR</var> * <var>TR</var> * <var>UR</var>' = <var>U</var> * <var>T</var> * <var>U</var>'</code> and
<code><var>U</var>' * <var>U</var></code> is the identity matrix I.
</p>
<p>Note also that <var>U</var> and <var>T</var> are not unique.
</p>
<p><strong>See also:</strong> <a href="#XREFschur">schur</a>.
</p></dd></dl>


<span id="XREFordschur"></span><dl class="def">
<dt id="index-ordschur"><span class="category">: </span><span><em>[<var>UR</var>, <var>SR</var>] =</em> <strong>ordschur</strong> <em>(<var>U</var>, <var>S</var>, <var>select</var>)</em><a href='#index-ordschur' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Reorders the real Schur factorization (<var>U</var>,<var>S</var>) obtained with the
<code>schur</code> function, so that selected eigenvalues appear in the upper left
diagonal blocks of the quasi triangular Schur matrix.
</p>
<p>The logical vector <var>select</var> specifies the selected eigenvalues as they
appear along <var>S</var>&rsquo;s diagonal.
</p>
<p>For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>, and its Schur
decomposition
</p>
<div class="example">
<pre class="example">[<var>U</var>, <var>S</var>] = schur (<var>A</var>)
</pre></div>

<p>which returns
</p>
<div class="example">
<pre class="example"><var>U</var> =

  -0.82456  -0.56577
   0.56577  -0.82456

<var>S</var> =

  -0.37228  -1.00000
   0.00000   5.37228

</pre></div>

<p>It is possible to reorder the decomposition so that the positive eigenvalue
is in the upper left corner, by doing:
</p>
<div class="example">
<pre class="example">[<var>U</var>, <var>S</var>] = ordschur (<var>U</var>, <var>S</var>, [0,1])
</pre></div>


<p><strong>See also:</strong> <a href="#XREFschur">schur</a>, <a href="#XREFordeig">ordeig</a>, <a href="#XREFordqz">ordqz</a>.
</p></dd></dl>


<span id="XREFordqz"></span><dl class="def">
<dt id="index-ordqz"><span class="category">: </span><span><em>[<var>AR</var>, <var>BR</var>, <var>QR</var>, <var>ZR</var>] =</em> <strong>ordqz</strong> <em>(<var>AA</var>, <var>BB</var>, <var>Q</var>, <var>Z</var>, <var>keyword</var>)</em><a href='#index-ordqz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ordqz-1"><span class="category">: </span><span><em>[<var>AR</var>, <var>BR</var>, <var>QR</var>, <var>ZR</var>] =</em> <strong>ordqz</strong> <em>(<var>AA</var>, <var>BB</var>, <var>Q</var>, <var>Z</var>, <var>select</var>)</em><a href='#index-ordqz-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Reorder the QZ&nbsp;decomposition of a generalized eigenvalue problem.
</p>
<p>The generalized eigenvalue problem is defined as
</p>

<p><em class='math'>A x = <var>lambda</var> B x</em>
</p>

<p>Its generalized Schur decomposition is computed using the <code>qz</code> algorithm:
</p>
<p><code>[<var>AA</var>, <var>BB</var>, <var>Q</var>, <var>Z</var>] = qz (<var>A</var>, <var>B</var>)</code>
</p>
<p>where <var>AA</var>, <var>BB</var>, <var>Q</var>, and <var>Z</var> fulfill
</p>
<div class="example">
<pre class="example">

<var>AA</var> = <var>Q</var> * <var>A</var> * <var>Z</var>, <var>BB</var> = <var>Q</var> * <var>B</var> * <var>Z</var>

</pre></div>


<p>The <code>ordqz</code> function computes a unitary transformation <var>QR</var> and
<var>ZR</var> such that the order of the eigenvalue on the diagonal of <var>AA</var> and
<var>BB</var> is changed.  The resulting reordered matrices <var>AR</var> and <var>BR</var>
fulfill:
</p>

<div class="example">
<pre class="example">

<var>AR</var> = <var>QR</var> * <var>A</var> * <var>ZR</var>, <var>BR</var> = <var>QR</var> * <var>B</var> * <var>ZR</var>

</pre></div>


<p>The function can either be called with the <var>keyword</var> argument which
selects the eigenvalues in the top left block of <var>AR</var> and <var>BR</var> in the
following way:
</p>
<dl compact="compact">
<dt><span><code>&quot;S&quot;</code>, <code>&quot;udi&quot;</code></span></dt>
<dd><p>small: leading block has all
|<var>lambda</var>| &lt; 1
</p>
</dd>
<dt><span><code>&quot;B&quot;</code>, <code>&quot;udo&quot;</code></span></dt>
<dd><p>big: leading block has all
|<var>lambda</var>| &ge; 1
</p>
</dd>
<dt><span><code>&quot;-&quot;</code>, <code>&quot;lhp&quot;</code></span></dt>
<dd><p>negative real part: leading block has all eigenvalues in the open left
half-plane
</p>
</dd>
<dt><span><code>&quot;+&quot;</code>, <code>&quot;rhp&quot;</code></span></dt>
<dd><p>non-negative real part: leading block has all eigenvalues in the closed right
half-plane
</p></dd>
</dl>

<p>If a logical vector <var>select</var> is given instead of a keyword the <code>ordqz</code>
function reorders all eigenvalues <code>k</code> to the left block for which
<code>select(k)</code> is true.
</p>
<p>Note: The keywords are compatible with the ones from <code>qr</code>.
</p>

<p><strong>See also:</strong> <a href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a href="#XREFordeig">ordeig</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFordschur">ordschur</a>.
</p></dd></dl>


<span id="XREFordeig"></span><dl class="def">
<dt id="index-ordeig"><span class="category">: </span><span><em><var>lambda</var> =</em> <strong>ordeig</strong> <em>(<var>A</var>)</em><a href='#index-ordeig' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-ordeig-1"><span class="category">: </span><span><em><var>lambda</var> =</em> <strong>ordeig</strong> <em>(<var>A</var>, <var>B</var>)</em><a href='#index-ordeig-1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the eigenvalues of quasi-triangular matrices in their order of
appearance in the matrix <var>A</var>.
</p>
<p>The quasi-triangular matrix <var>A</var> is usually the result of a Schur
factorization.  If called with a second input <var>B</var> then the generalized
eigenvalues of the pair <var>A</var>, <var>B</var> are returned in the order of
appearance of the matrix <code><var>A</var>-<var>lambda</var>*<var>B</var></code>.  The pair
<var>A</var>, <var>B</var> is usually the result of a QZ decomposition.
</p>

<p><strong>See also:</strong> <a href="#XREFordschur">ordschur</a>, <a href="#XREFordqz">ordqz</a>, <a href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a href="#XREFschur">schur</a>, <a href="#XREFqz">qz</a>.
</p></dd></dl>


<span id="XREFsubspace"></span><dl class="def">
<dt id="index-subspace"><span class="category">: </span><span><em><var>angle</var> =</em> <strong>subspace</strong> <em>(<var>A</var>, <var>B</var>)</em><a href='#index-subspace' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Determine the largest principal angle between two subspaces
spanned by the columns of matrices <var>A</var> and <var>B</var>.
</p></dd></dl>


<span id="XREFsvd"></span><dl class="def">
<dt id="index-svd"><span class="category">: </span><span><em><var>s</var> =</em> <strong>svd</strong> <em>(<var>A</var>)</em><a href='#index-svd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-svd-1"><span class="category">: </span><span><em>[<var>U</var>, <var>S</var>, <var>V</var>] =</em> <strong>svd</strong> <em>(<var>A</var>)</em><a href='#index-svd-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-svd-2"><span class="category">: </span><span><em>[<var>U</var>, <var>S</var>, <var>V</var>] =</em> <strong>svd</strong> <em>(<var>A</var>, &quot;econ&quot;)</em><a href='#index-svd-2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-svd-3"><span class="category">: </span><span><em>[<var>U</var>, <var>S</var>, <var>V</var>] =</em> <strong>svd</strong> <em>(<var>A</var>, 0)</em><a href='#index-svd-3' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-singular-value-decomposition"></span>
<p>Compute the singular value decomposition of <var>A</var>.
</p>
<p>The singular value decomposition is defined by the relation
</p>

<div class="example">
<pre class="example">A = U*S*V'
</pre></div>


<p>The function <code>svd</code> normally returns only the vector of singular values.
When called with three return values, it computes
<var>U</var>, <var>S</var>, and <var>V</var>.
For example,
</p>
<div class="example">
<pre class="example">svd (hilb (3))
</pre></div>

<p>returns
</p>
<div class="example">
<pre class="example">ans =

  1.4083189
  0.1223271
  0.0026873
</pre></div>

<p>and
</p>
<div class="example">
<pre class="example">[u, s, v] = svd (hilb (3))
</pre></div>

<p>returns
</p>
<div class="example">
<pre class="example">u =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867

s =

  1.40832  0.00000  0.00000
  0.00000  0.12233  0.00000
  0.00000  0.00000  0.00269

v =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867
</pre></div>

<p>When given a second argument that is not 0, <code>svd</code> returns an economy-sized
decomposition, eliminating the unnecessary rows or columns of <var>U</var> or
<var>V</var>.
</p>
<p>If the second argument is exactly 0, then the choice of decomposition is based
on the matrix <var>A</var>.  If <var>A</var> has more rows than columns then an
economy-sized decomposition is returned, otherwise a regular decomposition
is calculated.
</p>
<p>Algorithm Notes: When calculating the full decomposition (left and right
singular matrices in addition to singular values) there is a choice of two
routines in <small>LAPACK</small>.  The default routine used by Octave is <code>gesvd</code>.
The alternative is <code>gesdd</code> which is 5X faster, but may use more memory
and may be inaccurate for some input matrices.  There is a third routine
<code>gejsv</code>, suitable for better accuracy at extreme scale.  See the
documentation for <code>svd_driver</code> for more information on choosing a driver.
</p>
<p><strong>See also:</strong> <a href="#XREFsvd_005fdriver">svd_driver</a>, <a href="Sparse-Linear-Algebra.html#XREFsvds">svds</a>, <a href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>.
</p></dd></dl>


<span id="XREFsvd_005fdriver"></span><dl class="def">
<dt id="index-svd_005fdriver"><span class="category">: </span><span><em><var>val</var> =</em> <strong>svd_driver</strong> <em>()</em><a href='#index-svd_005fdriver' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-svd_005fdriver-1"><span class="category">: </span><span><em><var>old_val</var> =</em> <strong>svd_driver</strong> <em>(<var>new_val</var>)</em><a href='#index-svd_005fdriver-1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-svd_005fdriver-2"><span class="category">: </span><span><em></em> <strong>svd_driver</strong> <em>(<var>new_val</var>, &quot;local&quot;)</em><a href='#index-svd_005fdriver-2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Query or set the underlying <small>LAPACK</small> driver used by <code>svd</code>.
</p>
<p>Currently recognized values are <code>&quot;gesdd&quot;</code>, <code>&quot;gesvd&quot;</code>, and
<code>&quot;gejsv&quot;</code>.  The default is <code>&quot;gesvd&quot;</code>.
</p>
<p>When called from inside a function with the <code>&quot;local&quot;</code> option, the
variable is changed locally for the function and any subroutines it calls.
The original variable value is restored when exiting the function.
</p>
<p>Algorithm Notes: The <small>LAPACK</small> library routines <code>gesvd</code> and <code>gesdd</code>
are different only when calculating the full singular value decomposition (left
and right singular matrices as well as singular values).  When calculating just
the singular values the following discussion is not relevant.
</p>
<p>The newer <code>gesdd</code> routine is based on a Divide-and-Conquer algorithm that
is 5X faster than the alternative <code>gesvd</code>, which is based on QR
factorization.  However, the new algorithm can use significantly more memory.
For an MxN input matrix the memory usage is of order O(min(M,N) ^ 2),
whereas the alternative is of order O(max(M,N)).
</p>
<p>The routine <code>gejsv</code> uses a preconditioned Jacobi SVD algorithm.  Unlike
<code>gesvd</code> and <code>gesdd</code>, in <code>gejsv</code>, there is no bidiagonalization
step that could contaminate accuracy in some extreme cases.  Also, <code>gejsv</code>
is known to be optimally accurate in some sense.  However, the speed is slower
(single threaded at its core) and uses more memory (O(min(M,N) ^ 2 + M + N)).
</p>
<p>Beyond speed and memory issues, there have been instances where some input
matrices were not accurately decomposed by <code>gesdd</code>.  See currently active
bug <a href="https://savannah.gnu.org/bugs/?55564">https://savannah.gnu.org/bugs/?55564</a>.  Until these accuracy issues
are resolved in a new version of the <small>LAPACK</small> library, the default driver
in Octave has been set to <code>&quot;gesvd&quot;</code>.
</p>

<p><strong>See also:</strong> <a href="#XREFsvd">svd</a>.
</p></dd></dl>



<span id="XREFhoush"></span><dl class="def">
<dt id="index-housh"><span class="category">: </span><span><em>[<var>housv</var>, <var>beta</var>, <var>zer</var>] =</em> <strong>housh</strong> <em>(<var>x</var>, <var>j</var>, <var>z</var>)</em><a href='#index-housh' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Compute Householder reflection vector <var>housv</var> to reflect <var>x</var> to be
the j-th column of identity, i.e.,
</p>
<div class="example">
<pre class="example">(I - beta*housv*housv')x =  norm (x)*e(j) if x(j) &lt; 0,
(I - beta*housv*housv')x = -norm (x)*e(j) if x(j) &gt;= 0
</pre></div>

<p>Inputs
</p>
<dl compact="compact">
<dt><span><var>x</var></span></dt>
<dd><p>vector
</p>
</dd>
<dt><span><var>j</var></span></dt>
<dd><p>index into vector
</p>
</dd>
<dt><span><var>z</var></span></dt>
<dd><p>threshold for zero  (usually should be the number 0)
</p></dd>
</dl>

<p>Outputs (see Golub and Van Loan):
</p>
<dl compact="compact">
<dt><span><var>beta</var></span></dt>
<dd><p>If beta = 0, then no reflection need be applied (zer set to 0)
</p>
</dd>
<dt><span><var>housv</var></span></dt>
<dd><p>householder vector
</p></dd>
</dl>
</dd></dl>


<span id="XREFkrylov"></span><dl class="def">
<dt id="index-krylov"><span class="category">: </span><span><em>[<var>u</var>, <var>h</var>, <var>nu</var>] =</em> <strong>krylov</strong> <em>(<var>A</var>, <var>V</var>, <var>k</var>, <var>eps1</var>, <var>pflg</var>)</em><a href='#index-krylov' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Construct an orthogonal basis <var>u</var> of a block Krylov subspace.
</p>
<p>The block Krylov subspace has the following form:
</p>
<div class="example">
<pre class="example">[v a*v a^2*v &hellip; a^(k+1)*v]
</pre></div>

<p>The construction is made with Householder reflections to guard against loss
of orthogonality.
</p>
<p>If <var>V</var> is a vector, then <var>h</var> contains the Hessenberg matrix
such that <code>a*u == u*h+rk*ek'</code>, in which
<code>rk = a*u(:,k)-u*h(:,k)</code>, and <code>ek'</code> is the vector
<code>[0, 0, &hellip;, 1]</code> of length <var>k</var>.  Otherwise, <var>h</var> is
meaningless.
</p>
<p>If <var>V</var> is a vector and <var>k</var> is greater than <code>length (A) - 1</code>,
then <var>h</var> contains the Hessenberg matrix such that <code>a*u == u*h</code>.
</p>
<p>The value of <var>nu</var> is the dimension of the span of the Krylov subspace
(based on <var>eps1</var>).
</p>
<p>If <var>b</var> is a vector and <var>k</var> is greater than <var>m-1</var>, then <var>h</var>
contains the Hessenberg decomposition of <var>A</var>.
</p>
<p>The optional parameter <var>eps1</var> is the threshold for zero.  The default
value is 1e-12.
</p>
<p>If the optional parameter <var>pflg</var> is nonzero, row pivoting is used to
improve numerical behavior.  The default value is 0.
</p>
<p>Reference: A. Hodel, P. Misra, <cite>Partial Pivoting in the
Computation of Krylov Subspaces of Large Sparse Systems</cite>, Proceedings of
the 42nd IEEE Conference on Decision and Control, December 2003.
</p></dd></dl>


</div>
<hr>
<div class="header">
<p>
Next: <a href="Functions-of-a-Matrix.html">Functions of a Matrix</a>, Previous: <a href="Basic-Matrix-Functions.html">Basic Matrix Functions</a>, Up: <a href="Linear-Algebra.html">Linear Algebra</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
